[
    {
        "i18n": {
            "da": {
                "context": {
                    "if_type_equals_thrower_then_attack": "... ellers hvis fjendens type *er lig med* \"thrower\", så angrib...",
                    "uses_of_when": "Eksempler på de to ovennævnte brug af `when`:",
                    "more_examples": "Flere eksemple",
                    "else_shield": "... ellers, blokér.",
                    "if_distance_less_than_10_then_cleave": "...ellers hvis \"cleave\" (kløve) er klar *og* afstanden er *mindre end* 10m, så kløv...",
                    "if_not_enemy_then_move": "Hvis der er *ikke* en fjende, så gå...",
                    "if_enemy_then_attack": "Eksempel: Hvis du ser en fjende, så angrib den."
                },
                "description": {
                    "clojure": "",
                    "io": "En `if`-erklæring siger \"hvis A er sandt, så gør B\".\n\nDu kan også tilføje `else`, som siger \"ellers, så gør C istedet\".\n\nDu kan endda sætte `else` sammen med `if` for at sige \"hvis A er sandt, så gør B, ellers, hvis C er sandt, så gør D, ellers så gør E istedet.",
                    "lua": "En `if`-erklæring siger \"hvis A er sandt, så gør B\".\n\nDu kan også tilføje `else`, som siger \"ellers, så gør C istedet\".\n\nDu kan endda sætte `else` sammen med `if` for at sige \"hvis A er sandt, så gør B, ellers, hvis C er sandt, så gør D, ellers så gør E istedet.",
                    "coffeescript": "En `if`-erklæring siger \"hvis A er sandt, så gør B\".\n\nDu kan også tilføje `else`, som siger \"ellers, så gør C istedet\".\n\nDu kan endda sætte `else` sammen med `if` for at sige \"hvis A er sandt, så gør B, ellers, hvis C er sandt, så gør D, ellers så gør E istedet.",
                    "python": "En `if`-erklæring siger \"hvis A er sandt, så gør B\".\n\nDu kan også tilføje `else`, som siger \"ellers, så gør C istedet\".\n\nDu kan endda sætte `else` sammen med `if` for at sige \"hvis A er sandt, så gør B, ellers, hvis C er sandt, så gør D, ellers så gør E istedet.",
                    "javascript": "En `if`-erklæring siger \"hvis A er sandt, så gør B\".\n\nDu kan også tilføje `else`, som siger \"ellers, så gør C istedet\".\n\nDu kan endda sætte `else` sammen med `if` for at sige \"hvis A er sandt, så gør B, ellers, hvis C er sandt, så gør D, ellers så gør E istedet."
                }
            },
            "pl": {
                "description": {
                    "io": "Jak mówi słowo `if`(jeśli), \"jeśli to jest prawdą, zrób to\".\n\nMożesz także dodać `else` mówiące \"jeśli nie, zrób coś innego zamiast\".\n\nNawet możesz kombinować `else` z `if`: \"jeśli to jest prawdą, zrób to; jeśli nie i jeśli *to* jest prawdą, wykonaj *to*; w innym wypadku, wykonaj coś innego.\"",
                    "lua": "Jak mówi słowo `if`(jeśli), \"jeśli to jest prawdą, zrób to\".\n\nMożesz także dodać `else` mówiące \"jeśli nie, zrób coś innego zamiast\".\n\nNawet możesz kombinować `else` z `if`: \"jeśli to jest prawdą, zrób to; jeśli nie i jeśli *to* jest prawdą, wykonaj *to*; w innym wypadku, wykonaj coś innego.\"",
                    "coffeescript": "Jak mówi słowo `if`(jeśli), \"jeśli to jest prawdą, zrób to\".\n\nMożesz także dodać `else` mówiące \"jeśli nie, zrób coś innego zamiast\".\n\nNawet możesz kombinować `else` z `if`: \"jeśli to jest prawdą, zrób to; jeśli nie i jeśli *to* jest prawdą, wykonaj *to*; w innym wypadku, wykonaj coś innego.\"",
                    "python": "Jak mówi słowo `if`(jeśli), \"jeśli to jest prawdą, zrób to\".\n\nMożesz także dodać `else` mówiące \"jeśli nie, zrób coś innego zamiast\".\n\nNawet możesz kombinować `else` z `if`: \"jeśli to jest prawdą, zrób to; jeśli nie i jeśli *to* jest prawdą, wykonaj *to*; w innym wypadku, wykonaj coś innego.\"",
                    "javascript": "Jak mówi słowo `if`(jeśli), \"jeśli to jest prawdą, zrób to\".\n\nMożesz także dodać `else` mówiące \"jeśli nie, zrób coś innego zamiast\".\n\nNawet możesz kombinować `else` z `if`: \"jeśli to jest prawdą, zrób to; jeśli nie i jeśli *to* jest prawdą, wykonaj *to*; w innym wypadku, wykonaj coś innego.\""
                },
                "context": {
                    "more_examples": "Więcej przykładów",
                    "if_distance_less_than_10_then_cleave": "... inaczej: jeśli \"cleave\" jest gotowy *i* odległość jest *mniejsza niż* 10m, przetnij (cleave).",
                    "else_shield": "... w innym wypadku, broń się.",
                    "if_type_equals_thrower_then_attack": "... inaczej: jeśli typ wroga *równa się* \"thrower\" (miotacz), atakuj...",
                    "if_not_enemy_then_move": "Jeżeli *nie* ma przeciwnika, idź...",
                    "if_enemy_then_attack": "Przykład: jeżeli widzisz przeciwnika, to zaatakuj go."
                }
            },
            "nl-NL": {
                "context": {
                    "uses_of_when": "Voorbeelden van twee toepassingen van 'when' zoals hierboven bedoeld:",
                    "more_examples": "Meer voorbeelden",
                    "if_type_equals_thrower_then_attack": "... anders (else) , als (if) de vijand's type *gelijk is aan* \"thrower\", val dan aan....",
                    "else_shield": "... anders (else), gebruik je schild (shield).",
                    "if_distance_less_than_10_then_cleave": "... else if (anders, als...) \"cleave\" klaar is *en* de afstand is *kleiner dan* 10 meter, dan cleave...",
                    "if_not_enemy_then_move": "Als er *niet* een vijand is (dus geen vijand), loop dan...",
                    "if_enemy_then_attack": "Voorbeeld: als je een vijand ziet, val hem dan aan."
                },
                "description": {
                    "clojure": "Een 'if' (als) statement is eigenlijk een vraag die je jezelf stelt om te kiezen tussen verschillende opties.\n\nJe zegt dan tegen jezelf \"ALS het waar dat....\", dan kies ik hiervoor. Bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood\n\nJe kunt ook een 'else' clausule toevoegen, dan wordt het bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood. ANDERS koop ik bruin brood.\n\nEen 'if' kan maar een mogelijkheid bevatten. Om een 'if' clausule te hebben met meerdere statements, kan je het woord 'when' als een directe vervanger gebruiken of als je beide clausules wilt gebruiken kan je 'when' alleen (of beide) gebruiken in één van je statements.",
                    "lua": "Een 'if' (als) statement is eigenlijk een vraag die je jezelf stelt om te kiezen tussen verschillende opties.\n\nJe zegt dan tegen jezelf \"ALS het waar dat....\", dan kies ik hiervoor. Bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood\n\nJe kunt ook 'else' (anders) toevoegen, dan wordt het bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood. ANDERS koop ik bruin brood.",
                    "coffeescript": "Een 'if' (als) statement is eigenlijk een vraag die je jezelf stelt om te kiezen tussen verschillende opties.\n\nJe zegt dan tegen jezelf \"ALS het waar dat....\", dan kies ik hiervoor. Bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood\n\nJe kunt ook 'else' (anders) toevoegen, dan wordt het bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood. ANDERS koop ik bruin brood.",
                    "python": "Een 'if' (als) statement is eigenlijk een vraag die je jezelf stelt om te kiezen tussen verschillende opties.\n\nJe zegt dan tegen jezelf \"ALS het waar dat....\", dan kies ik hiervoor. Bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood\n\nJe kunt ook 'else' (anders) toevoegen, dan wordt het bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood. ANDERS koop ik bruin brood.",
                    "javascript": "Een 'if' (als) statement is eigenlijk een vraag die je jezelf stelt om te kiezen tussen verschillende opties.\n\nJe zegt dan tegen jezelf \"ALS het waar dat....\", dan kies ik hiervoor. Bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood\n\nJe kunt ook 'else' (anders) toevoegen, dan wordt het bijvoorbeeld: ALS het waar is dat de bakker wit brood heeft, dan koop ik wit brood. ANDERS koop ik bruin brood."
                }
            },
            "zh-HANT": {
                "name": "如果/否則",
                "context": {
                    "more_examples": "更多例子",
                    "if_type_equals_thrower_then_attack": ".....否則若敵人的屬性等同於投擲器,那就攻擊",
                    "else_shield": "....否則,防禦",
                    "if_distance_less_than_10_then_cleave": "....否則若\"cleave\"準備好,且距離少於10公尺,就劈砍",
                    "if_not_enemy_then_move": "如果沒有敵人,那就移動.....",
                    "if_enemy_then_attack": "例如:如果看見敵人,那就攻擊他"
                },
                "description": {
                    "clojure": "",
                    "python": "`if`=假如 : `假如`這是真的  ,觸發在`if`之後的程式\r\n    \r\n`else`=假如不是 : `假如不是` ,觸發在`elif`之後的程式\r\n  \r\n也可以組合`if`和`else`兩種用法, `假如`這是真的  ,觸發在`if`之後的程式,`假如不是` ,觸發在`elif`之後的程式",
                    "javascript": "if 語法的意思是 '如果這個敘述是真的，那麼就執行這件事'。\n\n同時你也可以添加 else 語法，表示 '否則，就執行另外那件事'。\n\n你可以在 else 後方搭配 if 語法表示 '如果這個敘述是真的，那麼就執行這件事；否則，如果*這個敘述*是真的，那麼就執行*那件事*；否則，執行其他件事'。"
                }
            },
            "de-DE": {
                "context": {
                    "uses_of_when": "Beispiele von zwei Anwendungen für `when` wie oben erwähnt:",
                    "more_examples": "Mehr Beispiele ",
                    "if_type_equals_thrower_then_attack": "... sonst wenn der Feind Typ *gleich* \"Werfer\" (thrower) ist, dann greife an ...",
                    "else_shield": "... sonst, Schild (shield).",
                    "if_distance_less_than_10_then_cleave": "... sonst wenn \"cleave\" bereit ist *und* die Distanz ist *weniger als* 10m, dann zerteile (cleave) ....",
                    "if_not_enemy_then_move": "Wenn da *nicht* ein Feind ist, dann bewege (move) ...",
                    "if_enemy_then_attack": "Beispiel: Wenn du einen Feind siehst, dann greife ihn an."
                },
                "description": {
                    "clojure": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\". Du kannst auch ein `else` Teil-Anweisung hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDas `if` kann nur eine einzelne Anweisung für jede Teil-Anweisung aufnehmen. Um eine `if` Anweisung mit mehreren Teil-Anweisungen zu haben, kannst du auch `when` als einen direkten Ersatz nutzen oder wenn du beide Teil-Anweisungen benötigst, dann kannst Du `when` als eine (oder beide) der einzelnen Anweisungen nutzen.",
                    "io": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\".\n\nDu kannst auch `else` hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDu kannst auch `else` mit `if` kombinieren, um zu sagen \"wenn dies wahr ist, dann mache das da; sonst wenn dies *wahr* ist, dann mache *das* da; sonst mache etwas anderes stattdessen\".",
                    "lua": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\".\n\nDu kannst auch `else` hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDu kannst auch `else` mit `if` kombinieren, um zu sagen \"wenn dies wahr ist, dann mache das da; sonst wenn dies *wahr* ist, dann mache *das* da; sonst mache etwas anderes stattdessen\".",
                    "coffeescript": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\".\n\nDu kannst auch `else` hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDu kannst auch `else` mit `if` kombinieren, um zu sagen \"wenn dies wahr ist, dann mache das da; sonst wenn dies *wahr* ist, dann mache *das* da; sonst mache etwas anderes stattdessen\".",
                    "python": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\".\n\nDu kannst auch `else` hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDu kannst auch `else` mit `if` kombinieren, um zu sagen \"wenn dies wahr ist, dann mache das da; sonst wenn dies *wahr* ist, dann mache *das* da; sonst mache etwas anderes stattdessen\".",
                    "javascript": "Die `if` Anweidung sagt \"wenn dies wahr ist, dann mach das da\".\n\nDu kannst auch `else` hinzufügen, um zu sagen \"sonst mache etwas anderes stattdessen\".\n\nDu kannst auch `else` mit `if` kombinieren, um zu sagen \"wenn dies wahr ist, dann mache das da; sonst wenn dies *wahr* ist, dann mache *das* da; sonst mache etwas anderes stattdessen\"."
                }
            },
            "it": {
                "context": {
                    "uses_of_when": "Esempi dei due usi per 'when' menzionato sopra :",
                    "more_examples": "Altri Esempi",
                    "if_type_equals_thrower_then_attack": "...altrimenti se il tipo del nemico è *equals* (uguale) \"thrower\", allora attacca...",
                    "else_shield": "...altrimenti, blocca con lo scudo.",
                    "if_distance_less_than_10_then_cleave": "...altrimenti se \"cleave\" è pronta *and* (e)  la distanza è *less than* (meno di) 10m, allora cleave...",
                    "if_not_enemy_then_move": "Se *not* (non) c'è un nemico, allora muoviti...",
                    "if_enemy_then_attack": "Esempio: Se vedi un nemico, allora attaccalo."
                },
                "description": {
                    "clojure": "L'istruzione `if` dice, \"se questo e' vero, allora fai quello\". Puoi anche aggiungere `else` per dire, \"altrimenti, fai qualcos'altro\"\n\n`if` puo' solo controllare un'unica istruzione alla volta. Per avere un `if` con piu' istruzioni puoi usare `when` al posto di `if` oppure se hai bisogno di entrambe le clausole puoi usare `when` con una (o entrambe) istruzioni",
                    "io": "L'istruzione `if` dice, \"se questo e' vero, allora fai quello\"\n\nPuoi anche aggiungere `else` per dire, \"altrimenti, fai qualcos'altro\"\n\nPuoi anche combinare `else` con `if` per dire, \"se questo e' vero, allora fai quello, altrimenti, se *quest'altro* e' vero, allora fai *quell'altro*; oppure, fai un'altra cosa\"",
                    "lua": "L'istruzione 'if' dice, \"se questo è vero, allora fai ciò\".\n\nPuoi anche aggiungere 'else' per dire, \"altrimenti, fai qualcos'altro invece\".\n\nPuoi anche combinare 'else' con 'if' per dire, \"se questo è vero, allora fai ciò; altrimenti, se *this* è vero, allora fai *that*; altrimenti, fai qualcos'altro.\"",
                    "coffeescript": "L'istruzione `if` dice, \"se questo e' vero, allora fai quello\"\n\nPuoi anche aggiungere `else` per dire, \"altrimenti, fai qualcos'altro\"\n\nPuoi anche combinare `else` con `if` per dire, \"se questo e' vero, allora fai quello, altrimenti, se *quest'altro* e' vero, allora fai *quell'altro*; oppure, fai un'altra cosa\"",
                    "python": "L'istruzione `if` dice, \"se questo e' vero, allora fai quello\"\n\nPuoi anche aggiungere `else` per dire, \"altrimenti, fai qualcos'altro\"\n\nPuoi anche combinare `else` con `if` per dire, \"se questo e' vero, allora fai quello, altrimenti, se *quest'altro* e' vero, allora fai *quell'altro*; oppure, fai un'altra cosa\"",
                    "javascript": "L'istruzione `if` dice, \"se questo e' vero allora fai quello\"."
                }
            },
            "lt": {
                "description": {
                    "python": "Komanda `if` (angl. \"jei\") sako: \"Jei tai yra tiesa, daryk tą (kodą)\"\n\nTaip pat galite pridėti `else` (\"kitaip\") tam, kad sakytumėte: \"kitaip, daryk ką nors kitą\"\n\nGalite net apjungti `else` su nauju `if` ir pasakyti \"Jei tai yra tiesa, daryk tą (kodą), kitaip Jei *tai* yra tiesa, daryk *aną*; kitaip, daryk ką nors kitą\""
                }
            },
            "es-ES": {
                "context": {
                    "uses_of_when": "Ejemplos de los dos usos para `when` mencionados anteriormente:",
                    "more_examples": "Más ejemplos",
                    "if_type_equals_thrower_then_attack": "... sino si el tipo del enemigo es *igual* a \"thrower\", entonces atacar...",
                    "else_shield": "... sino, \"shield\".",
                    "if_distance_less_than_10_then_cleave": "... sino si \"cleave\" está listo *y* la distancia es *menor que* 10m, entonces \"cleave\"...",
                    "if_not_enemy_then_move": "Si *no* hay ningún enemigo, entonces muévete...",
                    "if_enemy_then_attack": "Ejemplo: si ves un enemigo, entonces atácale."
                },
                "description": {
                    "io": "La sentencia `if` significa, \"si esto es verdad, entonces haz esto\".\nTambién puedes añadir `else` para decir, \"en otro caso, hacer otra cosa en su lugar\"\nTambién puedes combinar `else` con `if` para decir, \"si esto es verdad, entonces hacer esto; sino, si *esto* es verdad, entonces hacer *esto*; sino hacer esto otro.\"",
                    "lua": "La sentencia `if` significa, \"si esto es verdad, entonces haz esto\".\nTambién puedes añadir `else` para decir, \"en otro caso, hacer otra cosa en su lugar\"\nTambién puedes combinar `else` con `if` para decir, \"si esto es verdad, entonces hacer esto; sino, si *esto* es verdad, entonces hacer *esto*; sino hacer esto otro.\"",
                    "coffeescript": "La sentencia `if` significa, \"si esto es verdad, entonces haz esto\".\nTambién puedes añadir `else` para decir, \"en otro caso, hacer otra cosa en su lugar\"\nTambién puedes combinar `else` con `if` para decir, \"si esto es verdad, entonces hacer esto; sino, si *esto* es verdad, entonces hacer *esto*; sino hacer esto otro.\"",
                    "python": "La sentencia `if` significa, \"si esto es verdad, entonces haz esto\".\nTambién puedes añadir `else` para decir, \"en otro caso, hacer otra cosa en su lugar\"\nTambién puedes combinar `else` con `if` para decir, \"si esto es verdad, entonces hacer esto; sino, si *esto* es verdad, entonces hacer *esto*; sino hacer esto otro.\"",
                    "javascript": "La declaración 'if' indica, \"si esto es verdadero, entonces haz\".\n\nPuedes añadir 'else' para indicar, \"sino, haz esto otro\"\n\nPuedes combinar 'else' con 'if' para indicar, \"si esto es true, entonces haz esto; sino, si *esto* es true, entonces haz *esto\"; sino, haz esto.\""
                }
            },
            "es-419": {
                "name": "Si/Sino",
                "description": {
                    "clojure": "La declaración `if` dice,\" si esto es cierto, entonces haz esto \". También puede agregar una cláusula más para decir \", de lo contrario, hacer otra cosa\".\n\nEl `if` sólo puede tener una sola declaración para cada cláusula. Para tener una cláusula `if` con varias instrucciones, puede usar` when` como un reemplazo directo o si necesita ambas cláusulas se pueden utilizar `when` como uno (o ambos) de sus declaraciones individuales.",
                    "io": "La declaración `if` dice,\" si esto es cierto, entonces haz esto\".\n\nPuede también añadir `else` que dice,\" de lo contrario, hacer otra cosa en su lugar \".\n\nIncluso puedes combinar ` else` con `if` para decir, \"si esto es cierto, haz esto; de lo contrario, si  *this* es cierto, entonces haz *that*; de lo contrario, haga otra cosa en su lugar.\"",
                    "lua": "La declaración `if` dice,\" si esto es cierto, entonces haz esto\".\n\nPuede también añadir `else` que dice,\" de lo contrario, hacer otra cosa en su lugar \".\n\nIncluso puedes combinar ` else` con `if` para decir, \"si esto es cierto, haz esto; de lo contrario, si  *this* es cierto, entonces haz *that*; de lo contrario, haga otra cosa en su lugar.\"",
                    "coffeescript": "La declaración `if` dice,\" si esto es cierto, entonces haz esto\".\n\nPuede también añadir `else` que dice,\" de lo contrario, hacer otra cosa en su lugar \".\n\nIncluso puedes combinar ` else` con `if` para decir, \"si esto es cierto, haz esto; de lo contrario, si  *this* es cierto, entonces haz *that*; de lo contrario, haga otra cosa en su lugar.\"",
                    "python": "La declaración `if` dice,\" si esto es cierto, entonces haz esto\".\n\nPuede también añadir `else` que dice,\" de lo contrario, hacer otra cosa en su lugar \".\n\nIncluso puedes combinar ` else` con `if` para decir, \"si esto es cierto, haz esto; de lo contrario, si  *this* es cierto, entonces haz *that*; de lo contrario, haga otra cosa en su lugar.\"",
                    "javascript": "La declaración `if` dice,\" si esto es cierto, entonces haz esto\".\n\nPuede también añadir `else` que dice,\" de lo contrario, hacer otra cosa en su lugar \".\n\nIncluso puedes combinar ` else` con `if` para decir, \"si esto es cierto, haz esto; de lo contrario, si  *this* es cierto, entonces haz *that*; de lo contrario, haga otra cosa en su lugar.\""
                },
                "context": {
                    "uses_of_when": "Ejemplos de los dos usos para `when` mencionado anteriormente:",
                    "if_type_equals_thrower_then_attack": "...Si el enemigo es *igual* al tipo \"thrower\", entonces atacalo...",
                    "if_distance_less_than_10_then_cleave": "...más si \"partir\" está listo *y* la distancia es *menor a* 10m, entonces partir...",
                    "more_examples": "Más ejemplos",
                    "else_shield": ".... entonces, escudo.",
                    "if_not_enemy_then_move": "si *no* existe un enemigo, entonces muévete...",
                    "if_enemy_then_attack": "Ejemplo: Si tu ves a un enemigo, entonces atacalo."
                }
            },
            "zh-HANS": {
                "name": "如果/否则",
                "description": {
                    "javascript": "\"if\" 语句表示：“如果这是正确的，那么就执行”\n\n你也能增加“else”语句：否则，做其他事情代替它\n\n你可以把“else”和“if”连起来使用。比如：如果这个条件是对的，那么就做它；或者，那个条件是对的，那么做那个事情；否则，做其他事情。"
                }
            },
            "ru": {
                "description": {
                    "clojure": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\". Ты также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\".\n\n'if' может принимать только одно условие для каждого выражения. Для использования 'if' с несколькими условиями, ты можешь использовать либо 'when' как прямую замену или, если тебе нужны оба условия, то ты можешь использовать  'when' как один (или оба) из твоих одиночных выражений.",
                    "io": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\".\n\nТы также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\"\n\nТы также можешь комбинировать 'else' вместе с 'if', чтобы сказать \"если это истинно, то делай то; иначе, если что-то другое истинно, то делай что-то ещё; иначе делай что-то совсем другое.\"",
                    "lua": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\".\n\nТы также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\"\n\nТы также можешь комбинировать 'else' вместе с 'if', чтобы сказать \"если это истинно, то делай то; иначе, если что-то другое истинно, то делай что-то ещё; иначе делай что-то совсем другое.\"",
                    "coffeescript": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\".\n\nТы также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\"\n\nТы также можешь комбинировать 'else' вместе с 'if', чтобы сказать \"если это истинно, то делай то; иначе, если что-то другое истинно, то делай что-то ещё; иначе делай что-то совсем другое.\"",
                    "python": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\".\n\nТы также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\"\n\nТы также можешь комбинировать 'else' вместе с 'if', чтобы сказать \"если это истинно, то делай то; иначе, если что-то другое истинно, то делай что-то ещё; иначе делай что-то совсем другое.\"",
                    "javascript": "Оператор 'if' (если) означает \"если это истинно, тогда делай то\".\n\nТы также можешь добавить 'else' (иначе) чтобы сказать \"иначе, делай что-нибудь другое\"\n\nТы также можешь комбинировать 'else' вместе с 'if', чтобы сказать \"если это истинно, то делай то; иначе, если что-то другое истинно, то делай что-то ещё; иначе делай что-то совсем другое.\""
                },
                "context": {
                    "uses_of_when": "Примеры двух использований для `when` упомянутых выше:",
                    "more_examples": "Больше примеров",
                    "if_type_equals_thrower_then_attack": "... иначе если тип противника *равен* \"thrower\", тогда атака...",
                    "else_shield": "... иначе, shield.",
                    "if_distance_less_than_10_then_cleave": "... иначе если \"cleave\" готово *и* дистанция *меньше чем* 10м, тогда cleave",
                    "if_not_enemy_then_move": "Если здесь \"нет\" противника, тогда двигаться...",
                    "if_enemy_then_attack": "Пример: если Вы увидели противника, то атакуйте его"
                }
            },
            "pt-BR": {
                "context": {
                    "if_type_equals_thrower_then_attack": "...senão se o tipo do inimigo *equals* \"thrower\" (for da categoria thrower), então ataque...",
                    "more_examples": "Mais exemplos",
                    "uses_of_when": "Os exemplos dos dois usos para `when` mencionados acima:",
                    "else_shield": "senão, defenda.",
                    "if_distance_less_than_10_then_cleave": "senão se \"cleave\" estiver pronto *e* a distância for *menor que* 10m, então Cleave...",
                    "if_not_enemy_then_move": "Se isso *não* houver um inimigo, então mova-se...",
                    "if_enemy_then_attack": "Exemplo: Se você vê um inimigo, então ataque."
                },
                "description": {
                    "python": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\"\n\nVocê também pode usar `else` (senão) para dizer, \"caso contrário, faça isso no lugar\".\n\nVocê ainda pode combinar `else` com `if` para dizer, \"Se isto for verdadeiro, então faça isso; caso contrário, se *isto* for verdadeiro, então faça *isso*; caso contrário, faça algo no lugar.\"",
                    "coffeescript": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\"\n\nVocê também pode usar `else` (senão) para dizer, \"caso contrário, faça isso no lugar\".\n\nVocê ainda pode combinar `else` com `if` para dizer, \"Se isto for verdadeiro, então faça isso; caso contrário, se *isto* for verdadeiro, então faça *isso*; caso contrário, faça algo no lugar.\"",
                    "lua": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\"\n\nVocê também pode usar `else` (senão) para dizer, \"caso contrário, faça isso no lugar\".\n\nVocê ainda pode combinar `else` com `if` para dizer, \"Se isto for verdadeiro, então faça isso; caso contrário, se *isto* for verdadeiro, então faça *isso*; caso contrário, faça algo no lugar.\"",
                    "io": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\"\n\nVocê também pode usar `else` (senão) para dizer, \"caso contrário, faça isso no lugar\".\n\nVocê ainda pode combinar `else` com `if` para dizer, \"Se isto for verdadeiro, então faça isso; caso contrário, se *isto* for verdadeiro, então faça *isso*; caso contrário, faça algo no lugar.\"",
                    "clojure": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\". Você também pode adicionar else para dizer, \"caso contrário, fazer outra coisa\".\n\nSe o `if` só puder ter uma declaração por cada cláusula. Para se ter uma cláusula `if` com muitas declarações, você também pode usar `when` (quando) como substituto ou se você precisar de ambas as cláusulas, você pode usar `when`como um (ou ambos) de suas declarações individuais.",
                    "javascript": "Se o comando `if` (se) diz, \"Se isto for verdadeiro, então faça isso\"\n\nVocê também pode usar `else` (senão) para dizer, \"caso contrário, faça isso no lugar\".\n\nVocê ainda pode combinar `else` com `if` para dizer, \"Se isto for verdadeiro, então faça isso; caso contrário, se *isto* for verdadeiro, então faça *isso*; caso contrário, faça algo no lugar.\""
                }
            },
            "fr": {
                "description": {
                    "clojure": "La déclaration `if` dit : \"Si ceci est vrai, faire cela\". Vous pouvez aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nLe `if` peut prendre une seule déclaration pour chaque clause. Pour avoir une clause `if` à plusieurs déclaration, vous pouvez soit utiliser `when` directement, soit si vous avez besoin de deux clauses utiliser `when` comme une (ou deux) de vos déclarations.",
                    "python": "La déclaration `if` dit : \"Si ceci est vrai, faire cela\".\n\nTu peux aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nTu peux même combiner `else` avec `if` pour dire : \"Si ceci est vrai, faire cela, sinon faire quelque chose d'autre à la place\".",
                    "coffeescript": "La déclaration `if` dit : \"Si ceci est vrai, faire cela\".\n\nTu peux aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nTu peux même combiner `else` avec `if` pour dire : \"Si ceci est vrai, faire cela, sinon faire quelque chose d'autre à la place\".",
                    "lua": "La déclaration `if` dit : \"Si ceci est vrai, faire cela\".\n\nTu peux aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nTu peux même combiner `else` avec `if` pour dire : \"Si ceci est vrai, faire cela, sinon faire quelque chose d'autre à la place\".",
                    "io": "La déclaration `if` dit : \"Si ceci est vrai, faire cela\".\n\nTu peux aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nTu peux même combiner `else` avec `if` pour dire : \"Si ceci est vrai, faire cela, sinon faire quelque chose d'autre à la place\".",
                    "javascript": "La déclaration `if` dit : \"Si ceci est vrai, alors faire cela\".\n\nTu peux aussi ajouter `else` pour dire : \"Sinon, faire quelque chose d'autre\".\n\nTu peux même combiner `else` avec `if` pour dire : \"Si ceci est vrai, faire cela, sinon faire quelque chose d'autre à la place\"."
                },
                "context": {
                    "if_type_equals_thrower_then_attack": "... sinon, si le type d'ennemi *est* \"thrower\", alors attaque...",
                    "uses_of_when": "Exemples des deux utilisations de `when` mentionnées si dessus:",
                    "else_shield": "... sinon, shield.",
                    "if_distance_less_than_10_then_cleave": "ou si \"cleave\" est prêt *et* que la distance est *inferrieure* à 10m, alors cleave...",
                    "more_examples": "Plus d'exemples",
                    "if_not_enemy_then_move": "Si il *n'y a pas* d'ennemi, alors déplace toi...",
                    "if_enemy_then_attack": "Exemple : si tu vois un ennemi, alors attaque le."
                }
            },
            "pt-PT": {
                "context": {
                    "if_enemy_then_attack": "Exemplo: se vires um inimigo, então ataca-o.",
                    "more_examples": "Mais exemplos"
                }
            },
            "el": {
                "description": {
                    "clojure": "Η εντολή `if` δηλώνει ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \". Μπορείτε επίσης να προσθέσετε μια ρήτρα `else` για  να δηλώσετε  \"διαφορετικά, θα κάνω κάτι άλλο».\r\n\r\nΤο `if` μπορεί να πάρει μόνο μια εντολή για κάθε επιλογή. Για να έχετε μια εντολή `if` με πολλαπλές επιλογές, μπορείτε να χρησιμοποιήσετε είτε τη `when` ως άμεση αντικατάσταση ή αν χρειάζεστε όλες τις επιλογές μπορείτε να χρησιμοποιήσετε τη `when` στη ένα (ή σε όλες) τις μεμονωμένες εντολές σου.",
                    "io": "Οι εντολές  `if` δηλώνουν ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \".\r\n\r\nΜπορείτε επίσης να προσθέσετε `else` για να πείτε ότι ,\"Αλλιώς , θα κάνουμε κάτι άλλο αντι αυτού\".\r\n\r\nΜπορείτε να συνδυάσετε το `else` με `if` για να πείτε, \"αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό? Αλλιώς, αν αυτό είναι αλήθεια, τότε να κάνουμε αυτό?. Διαφορετικά, να κάνουμε κάτι άλλο αντί για αυτό\"",
                    "lua": "Οι εντολές  `if` δηλώνουν ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \".\r\n\r\nΜπορείτε επίσης να προσθέσετε `else` για να πείτε ότι ,\"Αλλιώς , θα κάνουμε κάτι άλλο αντι αυτού\".\r\n\r\nΜπορείτε να συνδυάσετε το `else` με `if` για να πείτε, \"αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό? Αλλιώς, αν αυτό είναι αλήθεια, τότε να κάνουμε αυτό?. Διαφορετικά, να κάνουμε κάτι άλλο αντί για αυτό\"",
                    "coffeescript": "Οι εντολές  `if` δηλώνουν ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \".\r\n\r\nΜπορείτε επίσης να προσθέσετε `else` για να πείτε ότι ,\"Αλλιώς , θα κάνουμε κάτι άλλο αντι αυτού\".\r\n\r\nΜπορείτε να συνδυάσετε το `else` με `if` για να πείτε, \"αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό? Αλλιώς, αν αυτό είναι αλήθεια, τότε να κάνουμε αυτό?. Διαφορετικά, να κάνουμε κάτι άλλο αντί για αυτό\"",
                    "python": "Οι εντολές  `if` δηλώνουν ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \".\r\n\r\nΜπορείτε επίσης να προσθέσετε `else` για να πείτε ότι ,\"Αλλιώς , θα κάνουμε κάτι άλλο αντι αυτού\".\r\n\r\nΜπορείτε να συνδυάσετε το `else` με `if` για να πείτε, \"αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό? Αλλιώς, αν αυτό είναι αλήθεια, τότε να κάνουμε αυτό?. Διαφορετικά, να κάνουμε κάτι άλλο αντί για αυτό\"",
                    "javascript": "Οι εντολές  `if` δηλώνουν ότι ,« αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό \".\r\n\r\nΜπορείτε επίσης να προσθέσετε `else` για να πείτε ότι ,\"Αλλιώς , θα κάνουμε κάτι άλλο αντι αυτού\".\r\n\r\nΜπορείτε να συνδυάσετε το `else` με `if` για να πείτε, \"αν αυτό είναι αλήθεια, τότε θα κάνουμε αυτό? Αλλιώς, αν αυτό είναι αλήθεια, τότε να κάνουμε αυτό?. Διαφορετικά, να κάνουμε κάτι άλλο αντί για αυτό\""
                },
                "context": {
                    "if_not_enemy_then_move": "Εάν δεν υπάρχει εχθρός τότε κινήσου.",
                    "if_distance_less_than_10_then_cleave": "αλλιώς εάν \"cleave\"  είναι διαθέσιμο και η απόσταση είναι μικρότερη από 10μ τότε διασπάση - cleave",
                    "else_shield": "...αλλιώς προστατέψου (shield)",
                    "more_examples": "Περισσότερα Παραδείγματα.",
                    "if_type_equals_thrower_then_attack": "... Αλλιώς αν ο εχθρός είναι τύπου \"thrower\",  τότε επίθεση ...",
                    "uses_of_when": " Παραδείγματα των δύο χρήσεων  για το `when`  αναφέρθηκαν παραπάνω:",
                    "if_enemy_then_attack": "Παράδειγμα : αν δείτε έναν εχθρό , τότε επίθεση στον εχθρό."
                }
            },
            "sk": {
                "description": {
                    "python": "Príkaz `if` hovorí, \"ak je toto pravda, tak urob tamto\".\n\nMôžeš tiež pridať `else` s významom \"inak urob miesto toho toto\".\n\n",
                    "javascript": "Príkaz `if` hovorí, \"ak je toto pravda, urob tamto\".\n\nMôžeš pridať aj `else`, ak chceš povedať \"inak, urob niečo iné miesto toho\".\n\nMôžeš aj skombinovať `else` s `if`, ak potrebuješ nasledovné \" ak je toto pravda, tak urob tamto; inak, ak je *toto* pravda, urob *tamto*;inak urob miesto toho niečo iné."
                }
            },
            "-": {
                "-": "-"
            }
        },
        "snippets": {
            "io": {
                "tab": "if",
                "code": "(if ${1:enemy},\n    ${2:}\n)"
            },
            "lua": {
                "tab": "if",
                "code": "if ${1:enemy} then\n    ${2:}\nend"
            },
            "clojure": {
                "tab": "if",
                "code": "(if ${1:enemy}\n    ${2:}\n)"
            },
            "coffeescript": {
                "tab": "if",
                "code": "if ${1:enemy}\n    ${2:}"
            },
            "python": {
                "tab": "if",
                "code": "if ${1:enemy}:\n    ${2:}"
            },
            "javascript": {
                "code": "if (${1:enemy}) {\n    ${2:}\n}",
                "tab": "if"
            }
        },
        "context": {
            "uses_of_when": "Examples of the two uses for `when` mentioned above:",
            "more_examples": "More examples",
            "if_type_equals_thrower_then_attack": "... else if the enemy's type *equals* \"thrower\", then attack...",
            "else_shield": "... else, shield.",
            "if_distance_less_than_10_then_cleave": "... else if \"cleave\" is ready *and* the distance is *less than* 10m, then cleave...",
            "if_not_enemy_then_move": "If there is *not* an enemy, then move...",
            "if_enemy_then_attack": "Example: if you see an enemy, then attack it."
        },
        "owner": "snippets",
        "example": {
            "io": "// <%= if_enemy_then_attack %>\nenemy := self:findNearestEnemy()\nif(enemy) then(\n    self:attack(enemy)\n)\n\n// <%= more_examples %>\nenemy := self:findNearestEnemy()\nif(enemy != nil) then(\n    // <%= if_not_enemy_then_move %>\n    moveXY(30, 30)\n) elseif(enemy type == \"thrower\") then(\n    // <%= if_type_equals_thrower_then_attack %>\n    attack(enemy)\n) elseif(isReady(\"cleave\") and distanceTo(enemy) < 10) then(\n    // <%= if_distance_less_than_10_then_cleave %>\n    cleave(enemy)\n) else(\n    // <%= else_shield %>\n    shield\n)",
            "clojure": ";; <%= if_enemy_then_attack %>\n(def enemy (.findNearestEnemy this))\n;; <%= uses_of_when %>\n(when enemy\n    (.attack this enemy)\n    (.say this \"Take that!\"))\n(if enemy\n    (when true\n        (.attack this enemy)\n        (.say this \"Take that!\"))\n    (.say this \"No enemy, so relax.\"))\n\n;; <%= more_examples %>\n(def enemy (.findNearest this (.findEnemies this)))\n(if (not enemy)         ;; <%= if_not_enemy_then_move %>\n    (.moveXY this 30 30)\n    (if (= (.type enemy) \"thrower\")\n        ;; <%= if_type_equals_thrower_then_attack %>\n        (.attack this enemy)\n        (if (and (.isReady this \"cleave\") (< (.distanceTo this enemy) 10))\n            ;; <%= if_distance_less_than_10_then_cleave %>\n            (.cleave this enemy)\n            (.shield this))))   ;; <%= else_shield %>",
            "lua": "-- <%= if_enemy_then_attack %>\nlocal enemy = self:findNearestEnemy()\nif enemy then\n    self:attack(enemy)\nend\n\n-- <%= more_examples %>\nlocal enemy = self:findNearestEnemy()\nif not enemy then\n    -- <%= if_not_enemy_then_move %>\n    self:moveXY(30, 30)\nelseif enemy.type == \"thrower\" then\n    -- <%= if_type_equals_thrower_then_attack %>\n    self:attack(enemy)\nelseif self:isReady(\"cleave\") and self:distanceTo(enemy) < 10 then\n    -- <%= if_distance_less_than_10_then_cleave %>\n    self:cleave(enemy)\nelse\n    -- <%= else_shield %>\n    self:shield()\nend",
            "coffeescript": "# <%= if_enemy_then_attack %>\nenemy = @findNearestEnemy()\nif enemy\n    @attack enemy\n\n# <%= more_examples %>\nenemy = @findNearestEnemy()\nif not enemy\n    # <%= if_not_enemy_then_move %>\n    @moveXY 30, 30\nelse if enemy.type is \"thrower\"\n    # <%= if_type_equals_thrower_then_attack %>\n    @attack enemy\nelse if @isReady(\"cleave\") and @distanceTo(enemy) < 10\n    # <%= if_distance_less_than_10_then_cleave %>\n    @cleave enemy\nelse\n    # <%= else_shield %>\n    @shield()",
            "python": "# <%= if_enemy_then_attack %>\nenemy = self.findNearestEnemy()\nif enemy:\n    self.attack(enemy)\n\n# <%= more_examples %>\nenemy = self.findNearestEnemy()\nif not enemy:\n    # <%= if_not_enemy_then_move %>\n    self.moveXY(30, 30)\nelif enemy.type is \"thrower\":\n    # <%= if_type_equals_thrower_then_attack %>\n    self.attack(enemy)\nelif self.isReady(\"cleave\") and self.distanceTo(enemy) < 10:\n    # <%= if_distance_less_than_10_then_cleave %>\n    self.cleave(enemy)\nelse:\n    # <%= else_shield %>\n    self.shield()",
            "javascript": "// <%= if_enemy_then_attack %>\nvar enemy = this.findNearestEnemy();\nif (enemy) {\n    this.attack(enemy);\n}\n\n// <%= more_examples %>\nvar enemy = this.findNearestEnemy();\nif (!enemy) {\n    // <%= if_not_enemy_then_move %>\n    this.moveXY(30, 30);\n}\nelse if (enemy.type == \"thrower\") {\n    // <%= if_type_equals_thrower_then_attack %>\n    this.attack(enemy);\n}\nelse if (this.isReady(\"cleave\") && this.distanceTo(enemy) < 10) {\n    // <%= if_distance_less_than_10_then_cleave %>\n    this.cleave(enemy);\n}\nelse {\n    // <%= else_shield %>\n    this.shield();\n}"
        },
        "description": {
            "clojure": "The `if` statement says, \"if this is true, then do that\". You can also add an else clause to say, \"otherwise, do something else\".\n\nThe `if` can only take single statement for each clause. To have an `if` clause with multiple statements, you can either use `when` as a direct replacement or if you need both clauses you can use `when` as one (or both) of your single statements.",
            "io": "The `if` statement says, \"if this is true, then do that\".\n\nYou can also add `else` to say, \"otherwise, do something else instead\".\n\nYou can even combine `else` with `if` to say, \"if this is true, then do that; otherwise, if *this* is true, then do *that*; otherwise, do something else instead.\"",
            "lua": "The `if` statement says, \"if this is true, then do that\".\n\nYou can also add `else` to say, \"otherwise, do something else instead\".\n\nYou can even combine `else` with `if` to say, \"if this is true, then do that; otherwise, if *this* is true, then do *that*; otherwise, do something else instead.\"",
            "coffeescript": "The `if` statement says, \"if this is true, then do that\".\n\nYou can also add `else` to say, \"otherwise, do something else instead\".\n\nYou can even combine `else` with `if` to say, \"if this is true, then do that; otherwise, if *this* is true, then do *that*; otherwise, do something else instead.\"",
            "python": "The `if` statement says, \"if this is true, then do that\".\n\nYou can also add `else` to say, \"otherwise, do something else instead\".\n\nYou can even combine `else` with `if` to say, \"if this is true, then do that; otherwise, if *this* is true, then do *that*; otherwise, do something else instead.\"",
            "javascript": "The `if` statement says, \"if this is true, then do that\".\n\nYou can also add `else` to say, \"otherwise, do something else instead\".\n\nYou can even combine `else` with `if` to say, \"if this is true, then do that; otherwise, if *this* is true, then do *that*; otherwise, do something else instead.\""
        },
        "type": "snippet",
        "name": "if/else"
    },
    {
        "i18n": {
            "pl": {
                "description": {
                    "javascript": "Pętla `for` pozwala Ci uruchamiać dany kod kilkukrotnie. Składa się z 4 części:\n\n* częsci inicjalizacyjnej (ustawienień wstępnych): `var i = 0;` (wykonywane na początku)\n* waruneku pętli: `i < 10` (wybrany kod wykonuje się dopóki warunek jest prawdziwy)\n* kroku pętli: `i += 1` (wykonywany po każdej iteracji pętli)\n* kodu pętli: `this.say(\"Policzyłem do \" + i);`"
                }
            },
            "es-419": {
                "name": "",
                "description": {
                    "python": "El ciclo `for` permite correr el código varias veces. Se puede utilizar el bucle sobre los elementos de una lista.\nPara repetir el código un número determinado de veces, el ciclo termina `range(n)`.",
                    "javascript": "El bucle 'for' permite ejecutar el código varias veces. Consta de cuatro partes:\n\n* configuracion inicial: `var i = 0;`  (corre en el comienzo)\n* condicion del bucle: `i < 10;`  (el código corre mientras esto sea cierto)\n* buce de iteración: `i += 1`  (corre despues de cada iteracion)\n* codigo principal del bucle: `this.say(\"Cuenta a \" + i);`"
                }
            },
            "da": {
                "description": {
                    "javascript": "`for`-løkken lader din kode køre mange gange. Den har 4 dele:\n\n* initiel setup:   `var i = 0;` (kører i begyndelsen)\n* løkkebetingelse: `i < 10;`    (kode kører sålænge dette er sandt)\n* løkkeiteration:  `i += 1`     (kører efter hver iteration)\n* løkkens kode:    `this.say(\"Talte til \" + i);`"
                }
            },
            "nl-NL": {
                "description": {
                    "python": "De 'for' loop laat je de code meerdere keren uitvoeren. Het kan gebruikt worden om door de verschillende elementen binnen een lijst te lopen.",
                    "javascript": "De 'for' loop zorgt ervoor dat jouw code meerdere keren wordt uitgevoerd. Het heeft vier onderdelen:\n\n* instellen: `var i = 0;`  (voer uit bij aanvang)\n* loop voorwaarde: `i < 10;`  (de code wordt uitgevoerd zolang (while) dit waar is)\n* loop iteratie: `i += 1`  (voer uit na iedere herhaling)\n* hoofd loop code: `this.say(\"Geteld tot\" + i);`"
                }
            },
            "es-ES": {
                "description": {
                    "javascript": "El búcle 'for' permite ejecutar una porción de código varias veces. Esta compuesto por cuatro elementos:\n\n* valor inicial: 'var i = 0;' (se ejecuta al inicio)\n* condición de búcle: 'i < 10;' (el código se ejecutará mientras esta condición sea cierta)\n* iteración de búcle: 'i += 1' (se ejecuta después de cada iteracción)"
                }
            },
            "el": {
                "description": {
                    "python": "Ο επανάληπτικός βρόχος `for` σας επιτρέπει να εκτελέσετε κώδικα πολλές φορές. Μπορεί να χρησιμοποιηθεί για να προσπελάσετε όλα τα στοιχεία μιας λίστας.\r\nΓια να επαναλάβετε ένα κομμάτι κώδικα, επαναλάβετε χρησιμοποιώντας τη `range(n)`",
                    "javascript": "Η `for` επανάληψη σας επιτρέπει να εκτελέσετε κώδικα πολλές φορές. Έχει τέσσερα μέρη:\r\n\r\n* Αρχική τιμή: `var i = 0?` (Εκτελείται μόνο στην αρχή)\r\n* Προϋπόθεση του βρόχου: `i <10?` (Ο Κώδικας εκτελείται μόνο εάν αυτό είναι αλήθεια)\r\n* Βήμα επανάληψης: `i += 1` ( εκτελείται μετά από κάθε επανάληψη)\r\n* Κύριο κώδικας Επανάληψης: `this.say (\"Μετρητής Επανάληψης\"+ i)?`"
                }
            },
            "de-DE": {
                "description": {
                    "python": "Die `for` Schleife lässt Dich Code mehrmals durchlaufen. Sie kann dazu benutzt werden, um über die Elemente einer Liste zu gehen.\nUm Code zu wiederholen setze eine Anzahl fest, gehe über `range(n)`\n",
                    "javascript": "Die `for` Schleife lässt dich Code mehrmals durchlaufen. Sie hat vier Teile:\n\n* initiales Einrichten:   `var i = 0;`  (läuft am Anfang)\n* Schleifen Bedingung:    `i < 10;`  (Code läuft während dies wahr (true) ist)\n* Schleifen Wiederholung: `i += 1`  (läuft nach jeder Wiederholung)\n* Hauptschleifen Code:    `this.say(\"Counted to \" + i);`"
                }
            },
            "it": {
                "description": {
                    "python": "Il ciclo `for` ti permette di eseguire del codice ripetutamente. Puo' essere usato per scandire gli elementi di una lista.\nPer ripetere del codice un numero definito di volte, esegui il ciclo con `range(n)`",
                    "javascript": "Il ciclo `for` ti permette di eseguire del codice ripetutamente. Ha quattro parti:\n\n* configurazione iniziale: `var i = 0;`  (viene eseguito all;inizio)\n* condizione del ciclo: `i < 10;`  (il codice viene eseguito finche' la condizione e' vera)\n* iterazione: `i += 1`  (viene eseguito dopo ogni iterazione del ciclo)\n* codice principale del ciclo: `this.say(\"Counted to \" + i);`"
                }
            },
            "pt-BR": {
                "description": {
                    "python": "O loop `for` (para) te deixa executar o código várias vezes. Ele  lets you run code many times. Ele pode ser utilizado para iterar os elementos de uma lista.\nPara repetir o código por um certo tanto de vezes, iterar `range(n)`.",
                    "javascript": "O loop `for` (para) permite você executar o código várias vezes. Ele tem quatro partes: \n\n* initial setup: `var i = 0;`  (executa no início)\n* loop condition: `i < 10;`  (o código executa enquanto for verdadeiro)\n* loop iteration: `i += 1`  (executa após cada iteração)\n* main loop code: `this.say(\"Counted to \" + i);`"
                }
            },
            "fr": {
                "description": {
                    "python": "La boucle `for` vous permet d'exécuter du code plusieurs fois. Elle peut être utiliser pour parcourir les éléments d'une liste.\nPour répéter du code un nombre donné de fois, boucler sur `range(n)`",
                    "javascript": "La boucle 'for' vous permet d'exécuter du code plusieurs fois.\n\nElle à quatre parties : \n\n* Initialisation : `var i = 0;` (exécuter au début)\n* condition de boucle : `i < 10;` (le code s'exécute tant que ceci est vrai)\n* répétition de boucle : `i += 1` (s'exécute à chaque répétition)\n* code de la boucle principale : `this.say(\"Compté jusqu'à \" + i);`"
                }
            },
            "ru": {
                "description": {
                    "python": "Цикл 'for' позволяет выполнять код много раз. Его можно использовать для перебора элементов списка.\nДля повторения кода заданное количество раз, необходимо использовать 'range(n)'\n",
                    "javascript": "Цикл 'for' позволяет тебе выполнять код много раз. Он состоит из четырех частей:\n\n* начало:        `var i = 0;` (выполняется в начале)\n* условие цикла: `i < 10;`    (тело цикла выполняется пока это условие верно)\n* шаг цикла:     `i += 1`     (выполняется после каждой итерации)\n* тело цикла:    `this.say(\"Counted to \" + i);`"
                }
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "example": {
            "python": "enemies = self.findEnemies()\nfor enemy in enemies:\n    self.say('I see you, ' + enemy.id)\n\n\nfor i in range(9):\n    self.say(\"Counted to \" + i)\n",
            "javascript": "var enemies = this.findEnemies();\nfor(var i = 0; i < enemies.length; i += 1) {\n    var enemy = enemies[i];\n    this.say('I see you, ' + enemy.id);\n}"
        },
        "description": {
            "python": "The `for` loop lets you run code many times. It can be used to loop over the elements of a list. \nTo repeat code a set number of times, loop over `range(n)`\n",
            "javascript": "The `for` loop lets you run code many times. It has four parts:\n\n* initial setup: `var i = 0;`  (run at the beginning)\n* loop condition: `i < 10;`  (code runs while this is true)\n* loop iteration: `i += 1`  (runs after every iteration)\n* main loop code: `this.say(\"Counted to \" + i);`"
        },
        "type": "snippet",
        "name": "for-loop"
    },
    {
        "i18n": {
            "pl": {
                "description": "Pętla `while` pozwala Ci na uruchamianie danego bloku kodu tak długo, dopóki podany warunek jest prawdziwy."
            },
            "es-419": {
                "description": "El bucle `while` te permite ejecutar código muchas veces - siempre y cuando la condición es verdadera."
            },
            "da": {
                "description": "En `while`-løkke lader dig køre kode mange gange--så længe dens betingelse er sand."
            },
            "nl-NL": {
                "description": "De 'while' (zolang) loop voert de code net zolang uit tot een bepaalde voorwaarde niet langer waar is. "
            },
            "es-ES": {
                "description": "El búcle 'while' te permite ejecutar código muchas veces, mientras la condición sea cierta (true)"
            },
            "pt-BR": {
                "description": "O loop `while` te permite executar o código muitas vezes - contanto que a condicional seja verdadeira."
            },
            "el": {
                "description": "Ο επαναληπτικός βρόχος `while` σας επιτρέπει να εκτελέσετε κώδικα πολλές φορές - εφ 'όσον η συνθήκη του `while` είναι αληθής."
            },
            "de-DE": {
                "description": "Die `while` Schleife lässt dich Code mehrmals durchlaufen -- solange die Bedingung wahr (true) ist."
            },
            "it": {
                "description": "Il ciclo 'while' ti permette di eseguire il codice varie volte--fin quando la condizione è vera."
            },
            "lt": {
                "description": "Ciklas `while` (angl. \"kol\") leidžia kartoti kodo vykdymą daug kartu - tol, kol sąlyga yra tenkinama. "
            },
            "fr": {
                "description": "La boucle `while` te permet d'exécuter ton code beaucoup de fois - tant que la condition est vraie."
            },
            "ru": {
                "description": "Цикл 'while' позволяет запускать Ваш код множество раз - до тех пор пока условие истинно."
            },
            "-": {
                "-": "-"
            }
        },
        "snippets": {
            "io": {
                "tab": "if",
                "code": "(while ${1:true},\n    ${2:}\n)"
            },
            "lua": {
                "tab": "if",
                "code": "while ${1:true} do\n    ${2:}\nend"
            },
            "clojure": {
                "tab": "if",
                "code": "(while ${1:true}\n    ${2:}\n)"
            },
            "coffeescript": {
                "tab": "while",
                "code": "while ${1:true}\n    ${2:}"
            },
            "python": {
                "tab": "if",
                "code": "while ${1:True}:\n    ${2:}"
            },
            "javascript": {
                "code": "while (${1:true}) {\n    ${2:}\n}",
                "tab": "while"
            }
        },
        "owner": "snippets",
        "example": {
            "clojure": "(def i 10)\n(while (>= i 0)\n    (.say this (str \"Counted to \" i))\n    (def i (dec i))\n)",
            "coffeescript": "i = 10\nwhile i >= 0\n    @say \"Counted to #{i}\n    i -= 1",
            "python": "i = 10\nwhile i >= 0:\n    self.say(\"Counted to \" + i)\n    i -= 1",
            "javascript": "var i = 10;\nwhile(i >= 0) {\n    this.say(\"Counted to \" + i);\n    i -= 1;\n}"
        },
        "description": "The `while` loop lets you run code many times--as long as the condition is true.",
        "type": "snippet",
        "name": "while-loop"
    },
    {
        "i18n": {
            "es-419": {
                "description": {
                    "clojure": "El bucle `doseq` te permite ejecutar codigo muchas veces, como el bucle `dotimes` excepto que opera a través de una secuencia, tales como las teclas de un mapa.\n\nAlgunos objetos se almacenan de forma diferente en Clojure que en Javascript (por ejemplo: mapas <==> diccionarios) por lo que no es necesario que haya una conversión de la salida de objeto de ciertas funciones: `(js->clj object)`. Afortunadamente, esto se mira similar a la operacion opuesta `(clj->js {:x x, :y y})` utilizado para crear objetos de posición.",
                    "python": "El bucle `for-in` te permite ejecutar código muchas veces, como un bucle de funcionamiento, excepto un poco más de las claves de un diccionario. El orden de repetición clave puede no ser coherente.",
                    "javascript": "El bucle `for-in` te permite ejecutar código muchas veces, como un bucle de funcionamiento, excepto que operan al lado de las teclas de un objeto o matriz. El orden de repetición clave puede no ser coherente."
                }
            },
            "da": {
                "description": {
                    "javascript": "`for-in`-løkken lader dig køre kode mange gange, som i en `for`-løkke undtagen at kun nøglerne til et objekt eller array itereres over. Rækkefølgen på nøglerne er ikke garanteret."
                }
            },
            "nl-NL": {
                "description": {
                    "clojure": "De 'doseq' loop voert de code meerdere keren uit, net als de 'dotimes' loop, behalve over een sequentie, zoals de keys van een map.\n\nSommige objecten worden in Clojure anders bewaard dan in JavaScript (bijvoorbeeld: maps<==>dictionaries) dus moet er een omzetting van de object output zijn van bepaalde functies: '(js->clj object)'. Hopelijk komt dit je bekend voor van de omgekeerde uitvoering '(clj->js {:x x, :y y})' welke wordt gebruikt om positie objecten te maken.",
                    "python": "De 'for-in' loop  voert de code meerdere keren uit, net als een for-loop, behalve dat deze alleen betrekking heeft op de keys van een dictonairy. De volgorde van de key iteraties hoeft niet consistent te zijn.",
                    "javascript": "de 'for-in' loop voert de code meerdere keren uit, net als een for-loop behalve dat deze alleen betrekking heeft over de keys van een object of een array. De volgorde van key iteraties hoeft niet consistent te zijn."
                }
            },
            "es-ES": {
                "description": {
                    "javascript": "El búcle 'for-in' te permite ejecutar código varias vez, de la misma forma que el búcle 'for'. Se diferencian en que 'for-in' opera sobre los índices/claves de un array/objecto. El orden de la clave de iteración puede no ser consistente."
                }
            },
            "pt-BR": {
                "description": {
                    "clojure": "O loop `doseq` (faça sequência) te permite execurar o código várias vezes, como o loop `dotimes` (faça x vezes) exceto executando por uma sequência, como uma chave de mapa.\n\nAlgums objetos são armazenados diferentemente em Clojure do que em Javascript (por exemplo: maps<==>dictionaries) é necessária uma conversão do objeto de saída de certas funções: `(js->clj object)`. Com sorte, isto soa familiar a partir da operação oposta `(clj->js {:x x, :y y})` usado para criar posições de objetos. ",
                    "python": "O loop `for-in` te permite executar o código muitas vezes, como o for-loop operando apenas por uma chave de um dicionário. A ordem da iteração chave pode não ser consistente.",
                    "javascript": "O loop `for-in` te permite executar o código muitas vezes, como o for-loop exceto operando apenas sobre as chaves de um objeto ou array. A ordem da iteração chave pode não ser consistente."
                }
            },
            "ru": {
                "description": {
                    "clojure": "Цикл 'doseq' позволяет выполнять код много раз, аналогичен циклу 'dotimes', за исключение того, что работает c последовательностями, такими как ключи карты.\n\nНекоторые объекты хранятся по разному в Clojure и в Javascript (например maps<==>directories) таким образом возникает необходимость в преобразовании возвращаемых объектов некоторых функций: '(js->clj object)'. К счастью это выглядит похожее не операцию обратного преобразования '(clj->js {:x x, :y y})' используемую для создания объектов, указывающих на позицию.",
                    "python": "Цикл 'for-in' позволяет выполнять код много раз, аналогичен циклу 'for', за исключение того, что работает только с объектами либо массивами. Порядок перебора элементов может быть не согласованным.",
                    "javascript": "Цикл 'for-in' позволяет выполнять код много раз, аналогичен циклу 'for', за исключение того, что работает только с объектами либо массивами. Порядок перебора элементов может быть не согласованным."
                }
            },
            "el": {
                "description": {
                    "python": "Ο επαναληπτικός βρόχος `for-in` σας επιτρέπει να εκτελέσετε κώδικα πολλές φορές, λειτουργεί όπως το for-loop, μόνο που εφαρμόζει τον επαναληπτικό βρόχο στα στοιχεία μιας λίστας ή ενός λεξικού.",
                    "javascript": "Ο επαναληπτικός βρόχος `for-in` σας επιτρέπει να εκτελέσετε κώδικα πολλές φορές, λειτουργεί όπως το for-loop, μόνο που εφαρμόζει τον επαναληπτικό βρόχο στα στοιχεία μιας λίστας."
                }
            },
            "de-DE": {
                "description": {
                    "clojure": "Die `doseq` Schleife lässt dich Code mehrmals durchlaufen, ähnlich der `dotimes` Schleifen außer dass sie über eine Sequenz funktioniert, solche wie die keys (Schlüssel) einer map (Karte).\n\nEinige Objekte werden unterschiedlich in Clojure als in JavaScript gespeichert (zum Beispiel: maps<==>dictionaries), so dass dort eine Konvertierung von Object Ausgaben bestimmter Funktionen benötigt wird: `(js->clj object)`. Hoffentlich sieht dies von der entgegengesetzten Operation vertraut aus `(clj->js {:x x, :y y})`, die zum Erstellen von Positionsobjekten genutzt wird.",
                    "python": "Die `for-in` Schleife lässt dich Code mehrmals durchlaufen, ähnlich einer for-Schleife außer dass sie über keys (Schlüssel) eines dictionary (Verzeichnis). Die Reihenfolge der keys (Schlüssel) Durchläufe müssen nicht gleichmäßig sein.",
                    "javascript": "Die `for-in` Schleife lässt dich Code mehrmals durchlaufen ähnlich einer for-Schleife außer dass sie über die keys (Schlüssel) eines Objektes oder Feldes funktioniert. Die Reihenfolge der keys (Schlüssel) Durchläufe müssen nicht gleichmäßig sein."
                }
            },
            "it": {
                "description": {
                    "clojure": "Il ciclo `doseq` ti permette di eseguire del codice ripetutamente, come un ciclo`dotimes` ma lavorando su una sequenza, come per esempio le chiavi di una mappa (struttura dati map)\n\nCerti oggetti sono archiviati in modo diverso in Clojure rispetto a Javascript (per esempio:  mappe<==>dizionari) quindi e' necessaria una conversione dell'output dell'oggetto in certe funzioni: `(js->clj object)`. Si spera che questo risulti ovvio dall'operazione opposta `(clj->js {:x x, :y y})` usata per creare oggetti di posizione.",
                    "python": "Il ciclo `for-in` ti permette di eseguire del codice ripetutamente, come un ciclo for-loop ma lavorando sulle chiavi di un dizionario. Le chiavi possono essere scandite fuori ordine.",
                    "javascript": "Il ciclo `for-in` ti permette di eseguire del codice ripetutamente, come un ciclo for-loop ma lavorando sulle chiavi di un oggetto o di un array. Le chiavi possono essere scandite fuori ordine."
                }
            },
            "fr": {
                "description": {
                    "python": "La boucle `for-in` te permet d'exécuter du code plusieurs fois, comme une boucle `for` excepté qu'elle ne parcourt que les clefs d'un dictionnaire. L'ordre de répétition des clefs peut ne pas être respecté.",
                    "clojure": "La boucle `doseq` te permet d'exécuter du code plusieurs fois, comme la boucle `dotimes` excepté qu'elle parcourt une séquence, telle que les clefs d'un dictionnaire.\n\nCertains objets sont stockés différemment en Clojure qu'en Javascript (par exemple les dictionnaires) et nécessitent donc une conversion de la sortie objet de certaines fonctions `(js->clj object)`. Heureusement, ceci ressemble à l'opposé de l'opération `(clj->js {:x x, :y y})` utilisée pour créer des objets position. ",
                    "javascript": "La boucle `for-in` te permet d'exécuter du code plusieurs fois, comme une boucle `for` excepté qu'elle ne parcourt que les clefs d'un objet ou tableau. L'ordre de répétition des clefs peut ne pas être respecté."
                }
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "example": {
            "clojure": "(def spells (js->clj (.spells this)))\n(doseq [spellName (keys spells)]\n    (def thisSpell (get spells spellName))\n    (.say this (str \"Spell \" spellName \" has range \" (get thisSpell \"range\"))))\n\n(doseq [bt (.buildTypes this)]\n    (if (= bt \"decoy\")\n        (.buildXY this \"decoy\" 36 30)\n        (.say this (str \"hmm, \" bt \", nope.\"))))",
            "python": "for spellName in self.spells:\n    spell = self.spells[spellName]\n    self.say('Spell ' + spellName + ' has range ' + spell.range)",
            "javascript": "for(var spellName in this.spells) {\n    var spell = this.spells[spellName];\n    this.say('Spell ' + spellName + ' has range ' + spell.range);\n}"
        },
        "description": {
            "clojure": "The `doseq` loop lets you run code many times, like the `dotimes` loop except operating over a sequence, such as the keys of a map.\n\nSome objects are stored differently in Clojure than in Javascript (for example: maps<==>dictionaries) so there needs to be a convertion of the object output of certain functions: `(js->clj object)`. Hopefully, this looks familiar from the opposite operation `(clj->js {:x x, :y y})` used to create position objects.",
            "python": "The `for-in` loop lets you run code many times, like a for-loop except operating just over the keys of a dictionary. The order of key iteration may not be consistent.",
            "javascript": "The `for-in` loop lets you run code many times, like a for-loop except operating just over the keys of an object or array. The order of key iteration may not be consistent."
        },
        "type": "snippet",
        "name": "for-in-loop"
    },
    {
        "i18n": {
            "es-419": {
                "description": "JavaScript objetos claves de mapa (cadenas) a las propiedades (cualquier tipo de valor).\n\nVer [Documentación de Mozilla \"Trabajando con objetos\"] (https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Trabajando_con_objectos) para obtener más información."
            },
            "da": {
                "description": "JavaScript objekter mapper nøgler (strenge) til egenskaber (af enhver type).\n\nSe [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects) for mere information."
            },
            "nl-NL": {
                "description": "JavaScript objecten delen keys (strings) in naar properties (elke type waarde).\n\nZie [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects) voor meer informatie."
            },
            "es-ES": {
                "description": "Los objectos JavaScript relacionan claves (keys) con propiedades. Las claves son cadenas (strings). Las propiedades pueden contener cualquier tipo de valor."
            },
            "pt-BR": {
                "description": "Objetos JavaScript chaves de mapa (strings) para propriedade (qualquer tipo de valor).\n\nVeja [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects) para mais informações."
            },
            "ru": {
                "description": "Объекты JavaScript используют ключи (строки) для доступа к свойствам (значения любых типов).\n\nСмотри [Документация Mozilla \"Работа с объектами\"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects)"
            },
            "it": {
                "description": "Gli oggetti JavaScript mappano chiavi (stringhe) su proprieta' (qualunque tipo di valore).\n\nVedi  [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Working_with_Objects) per ulteriori informazioni."
            },
            "de-DE": {
                "description": "JavaScript objects map keys (strings) zu properties (jeder Typ von Werten).\n\nSiehe [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects) für weitere Informationen."
            },
            "fr": {
                "description": "Les objets JavaScript associent des clefs (chaînes) à des propriétés (valeurs de type quelconque)\n\nRegarde la [documentation des objets Mozilla](https://developer.mozilla.org/fr-FR/docs/Web/JavaScript/Guide/Working_with_Objects) pour plus d'information."
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "example": {
            "python": "start = {'x': 30, 'y': 35}\nfoo['id'] = 'Starting Position'\nend = {'x': 50, 'y': 35, 'id': 'Ending Position'}\nrng = {'start': start}\nrng['end'] = end;\n\nfoo = {\"Keys must be surrounded by quotes\": \"single or double, matching\"};",
            "javascript": "var start = {x: 30, y: 35};\nfoo.id = 'Starting Position';\nvar end = {x: 50, y: 35, id: 'Ending Position'};\nvar range = {start: start};\nrange[end.id] = end;\n\nvar foo = {\"Keys with spaces\": \"need quotes\", shortKeys: \"don't\"};"
        },
        "description": "JavaScript objects map keys (strings) to properties (any type of value).\n\nSee [Mozilla's \"Working with Objects\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects) for more information.",
        "type": "snippet",
        "name": "objects"
    },
    {
        "i18n": {
            "zh-HANT": {
                "name": "排列"
            },
            "es-419": {
                "description": "Las matrices índices de mapa (integers) a elementos de la matriz (cualquier tipo de valor).\n\nVer [Documentación de Mozilla \"Array\"] (https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array) para obtener más información.   "
            },
            "da": {
                "description": "Arrays indekserer (heltal) array elementer (af enhver type).\n\nSe [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) for mere information."
            },
            "nl-NL": {
                "description": "Arrays delen indeces (integers) in naar array elementen (elk type waarde).\n\nZie [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) voor meer informatie."
            },
            "es-ES": {
                "description": "Los Arrays relacionan índices (números de tipo entero) con elementos (cualquier tipo de valor)\n\nConsulta  [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) para más información."
            },
            "pt-BR": {
                "description": "Índices de mapa arrays (números inteiros) para elementos de matriz (qualquer tipo de valor).\n\nVeja [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) para mais informações."
            },
            "ru": {
                "description": "Массивы используют индексы (целые числа) для доступа к элементам массива (значения любых типов).\n\nСмотри [Документация Mozilla \"Массивы\"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)."
            },
            "el": {
                "description": "Οι Πίνακες έχουν δείκτες(ακέραιοι) που επιτρέπουν την χαρτογράφηση των στοιχείων του πίνακα (που μπορεί να είναι κάθε είδους δεδομένα).\n\nΓια περισσότερες πληροφορίες δείτε [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)"
            },
            "it": {
                "description": "Gli Arrays mappano un indice (intero) su elementi di un array (qualunque tipo di valore)\n\nVedi  [Mozilla's \"Array\" documentation] (https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Array) per ulteriori informazioni."
            },
            "de-DE": {
                "description": "Arrays map indices (interger) zu array elements (jeder Typ von Werten).\n\nSiehe [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) für weitere Informationen."
            },
            "fr": {
                "description": "Les tableaux associent des indices (entiers) à des éléments de tableau (de type quelconque).\n\nRegarde la [documentation des tableaux Mozilla](https://developer.mozilla.org/fr-FR/docs/Web/JavaScript/Reference/Global_Objects/Array) pour plus d'information."
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "example": {
            "clojure": "(def arr [\"this is the first element\", \"this is the second element\"])\n(.say this (get arr 0))     ;; says \"this is the first element\"\n(.say this (get arr 1))     ;; says \"this is the second element\"\n(.say this (get arr (dec (count arr))))     ;; say the last element\n(.say this (last arr))      ;; also, say the last element\n\n(def arr (assoc arr 0 \"new first element\"))\n(def arr (conj arr \"a third element\" \"...\"))    ;; add new element(s) at the end",
            "python": "arr = [\"this is the first element\", \"this is the second element\"]\nself.say(arr[0])                # says \"this is the first element\"\nself.say(arr[1])                # says \"this is the second element\"\nself.say(arr[len(arr) - 1])     # says \"this is the second element\n\narr[0] = 'new first element'\narr.append('a third element')   # append() adds an element at the end\n\nlastElement = arr[-1]           # elements can be referenced from the end of the list using negative index values",
            "javascript": "var arr = [\"this is the first element\", \"this is the second element\"];\nthis.say(arr[0]);              // says \"this is the first element\"\nthis.say(arr[1]);              // says \"this is the second element\"\nthis.say(arr[arr.length - 1]); // says \"this is the second element\n\narr[0] = 'new first element';\narr.push('a third element');   // push() adds an element at the end"
        },
        "description": "Arrays map indices (integers) to array elements (any type of value).\n\nSee [Mozilla's \"Array\" documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) for more information.",
        "type": "snippet",
        "name": "arrays"
    },
    {
        "i18n": {
            "es-419": {
                "description": {
                    "clojure": "Las funciones te permiten crear un bloque de código reutilizable.",
                    "python": "Las funciones te permiten crear un bloque de código reutilizable.",
                    "javascript": "Funciones de JavaScript permiten crear un bloque de código reutilizable.\n\nVer [Documentación de Mozilla \"Funciones\"](https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Funciones) para obtener más información."
                }
            },
            "da": {
                "description": {
                    "javascript": "JavaScript funktioner lader dig lave en genbrugelig kodeblok.\n\nSe [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) for mere information."
                }
            },
            "nl-NL": {
                "description": {
                    "clojure": "Functies stellen je in staat een herbruikbaar blok code te schrijven.",
                    "python": "Functies stellen je in staat een herbruikbaar blok code te schrijven.",
                    "javascript": "JavaScript functies stellen je in staat om herbruikbare blokken code te schrijven.\n\nZie [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) voor meer informatie."
                }
            },
            "es-ES": {
                "description": {
                    "javascript": "Las funciones JavaScript permiten crear bloques de código reutilizables.\n\nConsulta [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) para más información."
                }
            },
            "pt-BR": {
                "description": {
                    "javascript": "Funções JavaScript te permite criar blocos de códigos reutilizáveis.\n\nVeja [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) para mais informações.",
                    "python": "Funções te permite criar blocos de códigos reutilizáveis.",
                    "clojure": "Funções te permite criar blocos de códigos reutilizáveis."
                }
            },
            "el": {
                "description": {
                    "javascript": "Οι συναρτήσεις της Javascript σας επιτρέπουν να δημιουργήσετε ένα επαναχρησιμοποιήσιμο κομμάτι κώδικα.\n\nΓια περισσότερες πληροφορίες δείτε [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)",
                    "python": "Οι συναρτήσεις σας επιτρέπουν να δημιουργήσετε ένα επαναχρησιμοποιήσιμο κομμάτι κώδικα.",
                    "clojure": "Οι συναρτήσεις σας επιτρέπουν να δημιουργήσετε ένα επαναχρησιμοποιήσιμο κομμάτι κώδικα."
                }
            },
            "de-DE": {
                "description": {
                    "clojure": "Funktionen lassen dich wiedernutzbare Code Blöcke erstellen.",
                    "python": "Funktionen lassen dich wiedernutzbare Code Blöcke erstellen.",
                    "javascript": "JavaScript Funktionen lassen dich wiedernutzbare Code Blöcke erstellen.\n\nSiehe [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) für weitere Informationen."
                }
            },
            "ru": {
                "description": {
                    "clojure": "Функции позволяют определять повторно используемые блоки кода",
                    "python": "Функции позволяют определять повторно используемые блоки кода",
                    "javascript": "Функции JavaScript позволяют создавать повторно используемые блоки кода.\n\nСмотри [Документация Mozilla по исопльзованию функций](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)."
                }
            },
            "it": {
                "description": {
                    "javascript": "Le funzioni JavaScript ti permettono di creare un blocco di codice riutilizzabile.\n\nVedi [Mozilla's function documentation] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) per ulteriori informazioni.",
                    "clojure": "Le funzioni ti permettono di creare un blocco di codice riutilizzabile.",
                    "python": "Le funzioni ti permettono di creare un blocco di codice riutilizzabile."
                }
            },
            "lt": {
                "description": {
                    "clojure": "Funkcijos leidžia sukurti daugkartinio panaudojimo kodo \"gabalą\".",
                    "python": "Funkcijos leidžia sukurti daugkartinio panaudojimo kodo \"gabalą\"."
                }
            },
            "fr": {
                "description": {
                    "clojure": "Les fonctions te permettent de créer un bloc de code réutilisable.",
                    "python": "Les fonctions te permettent de créer un bloc de code réutilisable.",
                    "javascript": "Les fonctions te permettent de créer un bloc de code réutilisable\n\nRegarde la [Documentation des fonctions Mozilla](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Fonctions) pour plus d'information."
                }
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "example": {
            "clojure": "(defn square [number]\n    (* number number))\n\n;; For functions that need access to your hero's `this`.\n;; When calling the function you pass in your `this` (see way below.)\n;; In the function definition, call it something else such as `me`.\n(defn moveUpAndDown [me times]\n    (dotimes [x times]\n           (.moveUp me)\n           (.moveDown me)))\n\n(def times (square 2))      ;; times is now 4\n(moveUpAndDown this times)  ;; will move up and down 4 times",
            "python": "def square(number):\n    return number * number\n\ndef moveUpAndDown(times):\n    for i in range(times):\n        self.moveUp()\n        self.moveDown()\n\ntimes = square(2)           # times is now 4\nself.moveUpAndDown(times)   # will move up and down 4 times",
            "javascript": "function square(number) {\n    return number * number;\n}\n\n// For functions that need to access `this`,\n// make them properties of `this`.\nthis.moveUpAndDown = function(times) {\n    for(var i = 0; i < times; ++i) {\n        this.moveUp();\n        this.moveDown();\n    }\n};\n\nvar times = square(2);      // times is now 4\nthis.moveUpAndDown(times);  // will move up and down 4 times"
        },
        "description": {
            "clojure": "Functions let you create a reusable block of code.",
            "python": "Functions let you create a reusable block of code.",
            "javascript": "JavaScript functions let you create a reusable block of code.\n\nSee [Mozilla's function documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) for more information."
        },
        "type": "snippet",
        "name": "functions"
    },
    {
        "i18n": {
            "es-419": {
                "description": "Las listas por comprensión proporcionan una forma concisa para crear listas. Las aplicaciones más comunes son para hacer nuevas listas donde cada elemento es el resultado de algunas operaciones aplicadas a cada miembro de otra secuencia o repetible, o para crear una subsecuencia de aquellos elementos que cumplan una determinada condición."
            },
            "nl-NL": {
                "description": "Lijst begrippen verschaffen een nauwkeurige manier om lijsten te maken. Vaak voorkomende toepassingen zijn het maken van nieuwe lijsten waar elk element een resultaat is van een bepaalde bewerking die is toegepast op elk lid van een andere sequentie, of om een sub-sequentie te maken van elementen die aan een bepaalde voorwaarden voldoen. "
            },
            "pt-BR": {
                "description": "Compreensão de lista permite de uma maneira concisa criar listas. As aplicações mais comuns para criar novas listas, onde cada elemento resulta em algumas operações aplicadas a cada membro de uma outra sequença iterável, ou criar uma subsequência desses elementos que satisfaçam a uma certa condição."
            },
            "ru": {
                "description": "Абстракция списков предоставляет простой способ создавать списки. Обычный вариант использования - создание новых списков, где каждый элемент является результатом какой-либо операции примененной к каждому элементу другой последовательности и т.д."
            },
            "el": {
                "description": "Η κατανόηση των λιστών σας παρέχει ένα συνοπτικό τρόπο για να δημιουργήσετε λίστες. Ως εφαρμογή μπορείτε να δημιουργήσετε νέες λίστες όπου κάθε στοιχείο είναι το αποτέλεσμα κάποιων διαδικασιών που εφαρμόζονται σε κάθε μέλος της άλλης λίστας ή για να δημιουργήσετε μια υπο-λίστα από τα στοιχεία που ικανοποιούν μια συγκεκριμένη συνθήκη."
            },
            "it": {
                "description": "List comprehensions fornisce un modo conciso per creare delle liste. Applicazioni tipiche sono la creazione di liste in cui ogni elemento e' il risultato di alcune operazioni applicate ad ogni valore di un'altra sequenza o oggetto iterabile, oppure la creazione di sottoinsiemi di valori che rispettano una certa condizione "
            },
            "de-DE": {
                "description": "Das Verständnis von Listen bietet eine kurzen Weg an Listen zu erstellen. Übliche Applikationen machen neue Listen, bei denen jedes Element das Ergebnis von einigen Operationen ist, die auf jedes Mitglied einer andere Sequenz oder Wiederholung angewendet wurden, oder zum Erstellen einer Subsequenz von solchen Elementen, die eine bestimmte Bendingung erfüllen."
            },
            "fr": {
                "description": "Les listes en compréhension fournissent un moyen rapide de créer des listes. Les utilisations habituelles sont de faire de nouvelles liste où chaque élément est le résultat d'opérations appliquées à chaque membre d'une autre liste ou de créer une séquence d'éléments qui satisfont une condition."
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "codeLanguages": [
            "python",
            "coffeescript"
        ],
        "example": {
            "lua": "-- Lua doesn't support list comprehensions.",
            "io": "// Io doesn't support list comprehensions.",
            "clojure": ";; CodeCombat Clojure doesn't support list comprehensions.",
            "coffeescript": "# Eat lunch.\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'",
            "javascript": "// JavaScript doesn't support list comprehensions.",
            "python": "squares = [x**2 for x in range(10)]\nbig_squares = [x for x in squares if x >= 36]\ncombos = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]"
        },
        "description": "List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.",
        "type": "snippet",
        "name": "list comprehensions"
    },
    {
        "autoCompletePriority": 3,
        "context": {
            "attacking_over_and_over": "Example: attack an enemy over and over.",
            "looping_through_a_maze": "Example: looping through a maze."
        },
        "i18n": {
            "da": {
                "context": {
                    "attacking_over_and_over": "Eksempel: Angrib en fjende igen og igen.",
                    "looping_through_a_maze": "Eksempel: Iterérer igennem en labyrint."
                },
                "description": {
                    "javascript": "`loop`-erklæringen lader dig køre den samme kode igen og igen. Indsæt koden, der skal gentages, imellem krølleparenteserne `{` og `}` med 4 mellemrum foran hver linje."
                }
            },
            "nl-NL": {
                "context": {
                    "attacking_over_and_over": "Voorbeeld: val de vijand steeds opnieuw aan. ",
                    "looping_through_a_maze": "Voorbeeld: herhalend door een doolhof."
                },
                "description": {
                    "io": "Met het woord 'loop', wordt een bepaald stuk code steeds opnieuw herhaald. **Deze functie wordt mogelijk nog niet ondersteund in Io.**",
                    "lua": "Met het woord 'loop', wordt een bepaald stuk code steeds opnieuw herhaald. Zet de code die je wil herhalen tussen de speciale woorden 'loop' (beginwoord) en 'end' (eindwoord), zet ook vier spaties voor iedere regel.",
                    "clojure": "Een makkelijke manier om een loop in Clojure uit te voeren is in de '(while true)' vorm.",
                    "coffeescript": "Met het woord 'loop', wordt een bepaald stuk code steeds opnieuw herhaald. Zet ***vier spaties*** vóór iedere lijn om deze te herhalen (zonder de spaties werkt het niet!).",
                    "python": "Met het woord 'loop', wordt een bepaald stuk code steeds opnieuw herhaald. Zet ***vier spaties*** vóór iedere lijn om deze te herhalen (zonder de spaties werkt het niet!).",
                    "javascript": "Met het woord 'loop', wordt een bepaald stuk code steeds opnieuw herhaald. De code die je wilt laten herhalen zet je tussen de accolades '{' en '}', met vier spaties vóór iedere regel."
                }
            },
            "es-ES": {
                "context": {
                    "attacking_over_and_over": "Ejemplo: ataca al enemigo una y otro vez.",
                    "looping_through_a_maze": "Ejemplo: haz un bucle a través del laberinto"
                },
                "description": {
                    "javascript": "La palabra clabe 'loop' te permite ejecutar código una y otra vez. Coloca el código a repetir entre llaves '{' y '}' con cuatro espacios al inicio de cada línea"
                }
            },
            "es-419": {
                "description": {
                    "lua": "Usa `loop` para ejecutar código una y otra vez. Pon el código de repetir dentro de las palabras clave  `loop` y `end`, con cuatro espacios antes de cada línea.",
                    "io": "La palabra clave `loop` te permite ejecutar código una y otra vez. ** Puede no funcionar aún en Io. **",
                    "python": "La palabra clave`bucle:` te permite ejecutar código una y otra vez. Ponga **cuatro espacios ** antes de cada línea de repetir o no va a funcionar!",
                    "javascript": "La palabra clave `loop` te permite ejecutar código una y otra vez. Pon el código para repetir el interior de las `{` and `}` llaves con cuatro espacios antes de cada línea."
                },
                "context": {
                    "looping_through_a_maze": "Ejemplo: un bucle a través de un laberinto",
                    "attacking_over_and_over": "Ejemplo: atacar a un enemigo una y otra vez."
                }
            },
            "el": {
                "description": {
                    "javascript": "Η loop` λέξη-κλειδί `σας επιτρέπει να εκτελέσετε κώδικα ξανά και ξανά. Βάλτε τον κώδικα που θα επαναλάβετε ανάμεσα στα αγκιστρα { και }, κρατώντας εσοχή τέσσαρων θέσεων σε κάθε γραμμή.",
                    "python": "Η loop` λέξη-κλειδί `σας επιτρέπει να εκτελέσετε κώδικα ξανά και ξανά. Kρατήστε εσοχή τέσσαρων θέσεων σε κάθε γραμμή ειδάλλως δεν θα λειτουργήσει.",
                    "coffeescript": "Η loop` λέξη-κλειδί `σας επιτρέπει να εκτελέσετε κώδικα ξανά και ξανά. Kρατήστε εσοχή τέσσαρων θέσεων σε κάθε γραμμή ειδάλλως δεν θα λειτουργήσει.",
                    "clojure": "Ένας εύκολος τρόπος για επαναληπτικό βρόχο στη Clojure είναι να χρησιμοποιήσετε την `while - true` μορφή.",
                    "lua": "Η εντολή `loop` σας επιτρέπει να εκτελέσετε κώδικα ξανά και ξανά χωρίς να σταματάει.Βάλτε τον κώδικα που θα επαναλάβετε ανάμεσα στις λέξεις `loop` και `end`, κρατώντας εσοχή τέσσαρων θέσεων σε κάθε γραμμή.",
                    "io": "Η εντολή `loop` σας επιτρέπει να εκτελέσετε κώδικα ξανά και ξανά χωρίς να σταματάει. ** Μπορεί να μην λειτουργεί ακόμη στην io. **"
                },
                "context": {
                    "looping_through_a_maze": "Παράδειγμα: επαναληπτική κίνηση μέσα σε ένα λαβύρινθο.",
                    "attacking_over_and_over": "Παράδειγμα: Επίθεση σε έναν εχθρό ξανά και ξανά."
                }
            },
            "lt": {
                "context": {
                    "attacking_over_and_over": "Pavyzdys: Vėl ir vėl atakuok priešą.",
                    "looping_through_a_maze": "Pavyzdys: cikliškas ėjimas per labirintą"
                },
                "description": {
                    "coffeescript": "Komanda `loop:` leidžia vykdyti kodo dalį vėl ir vėl, daugelį kartų. Tai vadinama ciklu. Būtinai įrašykite **keturis tarpus** prieš kiekvieną kartojamo kodo eilutę, kitaip `loop:`neveiks!",
                    "python": "Komanda `loop:` leidžia vykdyti kodo dalį vėl ir vėl, daugelį kartų. Tai vadinama ciklu. Būtinai įrašykite **keturis tarpus** prieš kiekvieną kartojamo kodo eilutę, kitaip `loop:`neveiks!"
                }
            },
            "pl": {
                "context": {
                    "looping_through_a_maze": "Przykład: robienie pętli przez labirynt.",
                    "attacking_over_and_over": "Przykład: atakuj przeciwnika w kółko."
                },
                "description": {
                    "lua": "Słowo kluczowe `loop` pozwala ci na powtarzanie kodu w kółko. Umieść kod pomiędzy słowa kluczowe `loop` i `end`, z czterema spacjami przed każdą linią.",
                    "clojure": "Prostym sposobem na zapętlanie w Clojure jest użycie `(while true)`.",
                    "coffeescript": "Słowo kluczowe `loop` pozwala ci na powtarzanie kodu w kółko. Umieść **cztery spacje** przed każdą linijką do powtórzenia albo nie będzie działać!",
                    "io": "Słowo kluczowe `loop` pozwala ci na powtarzanie kodu w kółko. **Może nie działać w Io.**",
                    "python": "Słowo kluczowe `loop` pozwala ci na powtarzanie kodu w kółko. Umieść **cztery spacje** przed każdą linijką do powtórzenia albo nie będzie działać!",
                    "javascript": "Słowo kluczowe `loop` pozwala ci na powtarzanie kodu w kółko. Umieść kod do powtórzenia pomiędzy nawiasy klamrowe `{` i `}` z czterema spacjami przed każdą linijką."
                }
            },
            "uk": {
                "context": {
                    "looping_through_a_maze": "Приклад: циклічно проходити через лабіринт.",
                    "attacking_over_and_over": "Приклад: атакувати ворога знов і знов."
                },
                "description": {
                    "io": "Ключове слово `loop` дозволяє вам виконувати код знов і знов. **Може поки що не працювати у Io.**",
                    "lua": "Використовуйте `loop`, щоб виконувати код знов і знов. Вмістіть код, що потрібно повторювати, між ключовими словами `loop` та `end`, з чотирма пробілами на початку кожного рядка.",
                    "clojure": "Простий спосіб організувати цикл у Clojure полягає у використанні `dotimes`.",
                    "coffeescript": "Ключове слово `loop` дозволяє вам виконувати код знов і знов. Видрукуйте **чотири пробіли** на початку кожного рядка, що повинен повторюватись, інакше це не буде працювати!",
                    "python": "Ключове слово `loop:` дозволяє вам виконувати код знов і знов. Видрукуйте **чотири пробіли** на початку кожного рядка, що повинен повторюватись, інакше це не буде працювати!",
                    "javascript": "Ключове слово `loop` дозволяє вам виконувати код знов і знов. Вмістіть код, що потрібно повторювати, між фігурними дужками `{` та `}`, з чотирма пробілами на початку кожного рядка."
                }
            },
            "it": {
                "description": {
                    "python": "La parola chiave `loop` ti permette di eseguire codice ripetutamente. Aggiungi **quattro spazi** prima di ogni linea da ripetere oppure non funzionera'!",
                    "javascript": "La parola chiave `loop` ti permette di eseguire codice ripetutamente. Scrivi il codice da ripetere tra parentesi graffe `{` e `}` mettendo quattro spazi prima di ogni linea.",
                    "coffeescript": "La parola chiave `loop` ti permette di eseguire codice ripetutamente. Aggiungi **quattro spazi** prima di ogni linea da ripetere oppure non funzionera'!",
                    "lua": "Usa la parola chiave `loop` per eseguire del codice ripetutamente. Scrivi il codice tra la parola chiave `loop` e `end` con quattro spazi prima di ogni linea.",
                    "io": "La parola chiave `loop` ti permette di eseguire codice ripetutamente. **Potrebbe non funzionare ancora in Io.**",
                    "clojure": "Un modo semplice di creare un ciclo in Clojure e' quello di usare il costrutto `(while true)`"
                },
                "context": {
                    "looping_through_a_maze": "Esempio: passeggia per un labirinto.",
                    "attacking_over_and_over": "Esempio: attacca un nemico a ripetizione.."
                }
            },
            "sk": {
                "context": {
                    "attacking_over_and_over": "Príklad: opakovaný útok na nepriateľa.",
                    "looping_through_a_maze": "Príklad: opakovanie pohybu bludiskom."
                },
                "description": {
                    "io": "Kľúčové slovo `loop` umožňuje opakovaný beh tvojho kódu. **Nemusí zatiaľ fungovať v  Io.**",
                    "lua": "Použi `loop` na opakovaný beh tvojho kódu. Vlož kód, ktorý chceš opakovať , medzi kľúčové slová `loop` a `end` so 4 medzerami pred každým riadkom kódu.",
                    "clojure": "Jednoduchým spôsobom, ako opakovať kód v Clojure, je použiť formu `dotimes`.",
                    "coffeescript": "Kľúčové slovo `loop` umožňuje opakovaný beh tvojho kódu. Daj  **4 medzery** pred každý riadok kódu, ktorý chceš opakovať, inak ti to nebude fungovať !",
                    "python": "Kľúčové slovo `loop` umožňuje opakovaný beh tvojho kódu. Daj  **4 medzery** pred každý riadok kódu, ktorý chceš opakovať, inak ti to nebude fungovať !",
                    "javascript": "Kľúčové slovo `loop` umožňuje opakovaný beh tvojho kódu.Vlož kód, ktorý chceš opakovať medzi  `{` a `}` so 4 medzerami pred každým riadkom kódu."
                }
            },
            "zh-HANT": {
                "name": "迴旋",
                "context": {
                    "attacking_over_and_over": "範例：重複不停地攻擊敵人",
                    "looping_through_a_maze": "範例：重複執行一樣的動作來通過迷宮"
                },
                "description": {
                    "io": "",
                    "lua": "使用 `loop` 來重複執行程式. 放置想要重複執行的程式在 `loop` 和 `end` 之間, 並且每行程式之前空出四個空格.",
                    "clojure": "在Clojure中，使用 `dotimes` 形式是一種簡單就可以做到重複執行的效果  ",
                    "coffeescript": "`loop:` 這個關鍵字讓您重複執行程式. 放置 **四個空格** 在每行程式之前，否則它是不會成功的！",
                    "python": "`loop:` 這個關鍵字讓您重複執行程式. 放置 **四個空格** 在每行程式之前，否則它是不會成功的！ ",
                    "javascript": "`loop` 這個關鍵字讓您重複執行程式. 把想要重複執行的程式放在 `{` 和 `}` 之間，並且每行程式之前空出四個空格."
                }
            },
            "zh-HANS": {
                "description": {
                    "javascript": "使用 `loop` 关键词一遍又一遍的执行代码。把需要重复的代码放在 `{` 和 `}` 中间，并每行缩进4个空格。",
                    "python": "使用 `loop` 关键词一遍又一遍的执行代码。把需要重复的代码放在 `loop` 和 `end` 关键词中间，并每行缩进4个空格，否则它无法工作。",
                    "coffeescript": "使用 `loop` 关键词一遍又一遍的执行代码。把需要重复的代码放在 `loop` 和 `end` 关键词中间，并每行缩进4个空格，否则它无法工作。",
                    "clojure": "在 Clojure 中通过使用 `dotimes` 可以轻松的使用循环。",
                    "lua": "使用 `loop` 关键词一遍又一遍的执行代码。把需要重复的代码放在 `loop` 和 `end` 关键词中间，并每行缩进4个空格。",
                    "io": "`loop` 关键字让你一遍又一遍的运行你的代码。**Io语言中可能还不能执行。**"
                },
                "context": {
                    "attacking_over_and_over": "举例：一次又一次攻击敌人。",
                    "looping_through_a_maze": "举例：循环通过迷宫。"
                }
            },
            "ru": {
                "context": {
                    "attacking_over_and_over": "Пример повторяющейся атаки врага.",
                    "looping_through_a_maze": "Пример \"зацикливания\" прохождения через лабиринт."
                },
                "description": {
                    "io": "Оператор 'loop:' позволяет выполнять блок кода снова и снова. **Возможно пока не работает в Io.**",
                    "lua": "Используйте `loop` чтобы выполнять код снова и снова. Размещайте повторяемый код между ключевыми словами `loop` и `end` с отступом (четыре пробела) перед каждой строкой.",
                    "clojure": "Наиболее простой способ организации цикла в Clojure - это использование выражения `(while true)`.",
                    "coffeescript": "Ключевое слово `loop` позволяет выполнять код снова и снова. Делайте отступ (четыре пробела) перед каждой повторяемой строкой, иначе работать не будет!",
                    "python": "Ключевое слово `loop:` позволяет выполнять код снова и снова. Делайте отступ (четыре пробела) перед каждой повторяемой строкой, иначе работать не будет!",
                    "javascript": "Оператор 'loop' позволяет выполнять блок кода снова и снова. Поместите код, выполнение которого необходимо повторять между фигурными скобками '{' и '}' и поставьте 4 пробела в начале каждой строки."
                }
            },
            "pt-BR": {
                "description": {
                    "lua": "Use `loop` (laço) para executar um código repetidas vezes. Coloque o código para repetir dentro das palavras chave `loop` e `end`, com 4 espaços antes de cada linha.",
                    "io": "A palavra chave `loop` (laço) te permite executar um código repetidas vezes. **Talvez não funcione ainda em IO.**",
                    "javascript": "A palavra chave `loop` te permite executar um código repetidas vezes. Coloque o código para repetir dentro de chaves `{` e `}` com quatro espaços antes de cada linha.",
                    "coffeescript": "A palavra chave `loop` (laço) te permite executar um código repetidas vezes. Coloque **quatro espaços** antes de cada linha para repetir, ou não irá funcionar!",
                    "python": "A palavra chave `loop` te permite executar um código repetidas vezes. Coloque **quatro espaços** antes de cada linha para repetir, ou não irá funcionar!",
                    "clojure": "Um jeito fácil de executar um loop em Clojure é utilizando o formulário `(while true)` (enquanto verdadeiro)."
                },
                "context": {
                    "attacking_over_and_over": "Exemplo: ataque um inimigo várias vezes.",
                    "looping_through_a_maze": "Exemplo: efetuando loop dentro de um labirinto."
                }
            },
            "pt-PT": {
                "context": {
                    "attacking_over_and_over": "Exemplo: atacar um inimigo sem parar.",
                    "looping_through_a_maze": "Exemplo: navegar através de um labirinto."
                },
                "description": {
                    "javascript": "O `loop` permite-te executar código sem parar. Põe o código a ser repetido dentro dos parêntesis `{` e `}`, com quatro espaços antes de cada linha.",
                    "lua": "Usa um `loop` para executares código sem parar. Põe o código a ser repetido dentro de `loop` e `end`, com quatro espaços antes de cada linha.",
                    "coffeescript": "O `loop` permite-te executar código sem parar. Põe **quatro espaços** antes de cada linha a ser repetida, senão não vai funcionar!",
                    "python": "O `loop:` permite-te executar código sem parar. Põe **quatro espaços** antes de cada linha a ser repetida, senão não vai funcionar!",
                    "io": "O `loop` permite-te executar código sem parar. **Pode ainda não funcionar em Io.**",
                    "clojure": "Uma forma fácil de fazeres 'loop' em Clojure é usando a forma `dotimes`."
                }
            },
            "de-DE": {
                "context": {
                    "attacking_over_and_over": "Beispiel: Einen Gegner wieder und wieder angreifen.",
                    "looping_through_a_maze": "Beispiel: Wiederholt durch einen Irrgarten gehen."
                },
                "description": {
                    "io": "Das Schlüsselwort `loop` lässt dich Code wieder und wieder durchlaufen. **Vielleicht funktioniert es noch nicht in Io.\"",
                    "lua": "Benutze `loop` um Code wieder und wieder durchlaufen zu lassen. Stecke den Code zum Wiederholen zwischen dem `loop` und `end` Schlüsselwörtern, mit vier Leerzeichen vor jeder Zeile.",
                    "clojure": "Ein einfacher Weg Schleifen in Clojur zu nutzen ist die `(while true)` Form.",
                    "coffeescript": "Das Schlüsselwort `loop` lässt dich Code wieder und wieder ausführen. Stelle **vier Leerschritte** vor jeder zu wiederholenden Zeile oder es wird nicht funktionieren!",
                    "python": "Das Schlüsselwort `loop:` lässt dich Code wieder und wieder ausführen. Stelle **vier Leerschritte** vor jeder zu wiederholenden Zeile oder es wird nicht funktionieren!",
                    "javascript": "Das Schlüsselwort `loop` lässt dich Code wieder und wieder ausführen. Stecke den Code zum Wiederholenn zwischen die `{` und `}` geschweiften Klammern mit vier Leerschritten vor jeder Zeile."
                }
            },
            "nb": {
                "context": {
                    "attacking_over_and_over": "Eksempel: angrip en fiende om og om igjen.",
                    "looping_through_a_maze": "Eksempel: gå gjennom en labyrint med en loop"
                },
                "description": {
                    "io": "`loop`-nøkkelordet lar det kjøre kode om og om igjen. **Kanhende det ikke virker i Io.**",
                    "lua": "Bruk `while true do` for å kjøre kode om og om igjen.  Putt koden du vil gjenta mellom `do` og `end`-nøkkelordene, med fire mellomrom på begynnelsen av hver linje.",
                    "clojure": "En enkel måte å gjøre løkker i Clojure er å bruke `dotimes`.",
                    "coffeescript": "`loop`-nøkkelordet lar det kjøre kode om og om igjen. Putt **fire mellomrom** på begynnelsen av hver linje koden du vil gjenta, ellers virker det ikke!",
                    "python": "`loop`-nøkkelordet lar det kjøre kode om og om igjen. Putt **fire mellomrom** på begynnelsen av hver linje koden du vil gjenta, ellers virker det ikke!",
                    "javascript": "`loop`-nøkkelordet lar det kjøre kode om og om igjen. Putt koden du vil gjenta inni `{` og `}` parantes med fire mellomrom først på linjen."
                }
            },
            "fr": {
                "description": {
                    "javascript": "Le mot-clef `loop` te permet d'exécuter du code encore et encore. Place le code à répéter entre les accolades `{` et `}` avec quatre espaces devant chaque ligne.",
                    "python": "Le mot-clef `loop` te permet d'exécuter du code encore et encore. Mets **quatre espaces** devant chaque ligne à répéter pour que ça marche !",
                    "coffeescript": "Le mot-clef `loop` te permet d'exécuter du code encore et encore. Mets **quatre espaces** devant chaque ligne à répéter pour que ça marche !",
                    "clojure": "Un moyen simple de boucler en Clojure est d'utiliser l'instruction `dotimes`.",
                    "lua": "Utilise `loop` pour exécuter du code encore et encore. Place le code à répéter entre les mots-clefs `loop` et `end`, avec quatre espaces devant chaque ligne.",
                    "io": "Le mot-clef `loop` te permet d'exécuter du code encore et encore. **Peut ne pas fonctionner en Io.**"
                },
                "context": {
                    "looping_through_a_maze": "Exemple : Répéter les memes actions a travers d'un labyrinthe.",
                    "attacking_over_and_over": "Exemple : Attaquez un ennemi encore et encore."
                }
            },
            "-": {
                "-": "-"
            }
        },
        "owner": "snippets",
        "snippets": {
            "io": {
                "tab": "loop",
                "code": "(loop\n    ${1:}\n)"
            },
            "lua": {
                "tab": "loop",
                "code": "loop\n    ${1:}\nend"
            },
            "clojure": {
                "tab": "loop",
                "code": "(dotimes [n 1000]\n    ${1:}\n)"
            },
            "coffeescript": {
                "tab": "loop",
                "code": "loop\n    ${1:}"
            },
            "python": {
                "tab": "loop",
                "code": "loop:\n    ${1:}"
            },
            "javascript": {
                "code": "loop {\n    ${1:}\n}",
                "tab": "loop"
            }
        },
        "example": {
            "io": "// <%= looping_through_a_maze %>\nwhile(true,\n    moveRight\n    moveDown\n    moveUp\n    moveRight)\n\n// <%= attacking_over_and_over %>\nwhile(true,\n    enemy := findNearestEnemy\n    if(enemy) then(\n        attack(enemy)\n    )\n)",
            "lua": "-- <%= looping_through_a_maze %>\nloop\n    self:moveRight()\n    self:moveDown()\n    self:moveRight()\n    self:moveUp()\nend\n\n-- <%= attacking_over_and_over %>\nloop\n    local enemy = self:findNearestEnemy()\n    if enemy then\n        self:attack(enemy)\n    end\nend",
            "clojure": ";; <%= looping_through_a_maze %>\n(while true\n    (.moveRight this)\n    (.moveDown this)\n    (.moveRight this)\n    (.moveUp this))\n\n;; <%= attacking_over_and_over %>\n(while true\n    (def enemy (.findNearestEnemy this))\n    (if enemy\n        (.attack this enemy)\n    ))",
            "coffeescript": "# <%= looping_through_a_maze %>\nloop\n    @self.moveRight()\n    @self.moveDown()\n    @self.moveUp()\n    @self.moveRight()\n\n# <%= attacking_over_and_over %>\nloop\n    enemy = @findNearestEnemy()\n    if enemy\n        @attack enemy",
            "python": "# <%= looping_through_a_maze %>\nloop:\n    self.moveRight()\n    self.moveDown()\n    self.moveRight()\n    self.moveUp()\n\n# <%= attacking_over_and_over %>\nloop:\n    enemy = self.findNearestEnemy()\n    if enemy:\n        self.attack(enemy)",
            "javascript": "// <%= looping_through_a_maze %>\nloop {\n    this.moveRight();\n    this.moveDown();\n    this.moveRight();\n    this.moveUp();\n}\n\n// <%= attacking_over_and_over %>\nloop {\n    var enemy = this.findNearestEnemy();\n    if (enemy) {\n        this.attack(enemy);\n    }\n}"
        },
        "description": {
            "io": "The `loop` keyword lets you run code over and over again. **May not work yet in Io.**",
            "lua": "Use `loop` to run code over and over again. Put the code to repeat inside the `loop` and `end` keywords, with four spaces before each line.",
            "clojure": "An easy way to loop in Clojure is to use the `(while true)` form.",
            "coffeescript": "The `loop` keyword lets you run code over and over again. Put **four spaces** before each line to repeat or it won't work!",
            "python": "The `loop:` keyword lets you run code over and over again. Put **four spaces** before each line to repeat or it won't work!",
            "javascript": "The `loop` keyword lets you run code over and over again. Put the code to repeat inside the `{` and `}` curly braces with four spaces before each line."
        },
        "type": "snippet",
        "name": "loop"
    },
    {
        "owner": "snippets",
        "i18n": {
            "da": {
                "description": "`else`-erlæringen kan efterfølge en `if` til at gøre noget andet end hvis *if*-betingelsen ikke er sand."
            },
            "pl": {
                "description": "Klauzula `else` może wystąpić po `if`, żeby zrobić coś *innego*, gdy warunek *if* nie jest prawdą."
            },
            "nl-NL": {
                "description": "De 'else' (anders) clausule kan volgen na een 'if' (als) om iets *anders* te doen als de *als* voorwaarde niet waar is."
            },
            "es-ES": {
                "description": "La cláusula 'else' puede ir a continuación de una clásula 'if' para ejecutar algo cuando la condición del *if* no se cumple (false)"
            },
            "es-419": {
                "description": "La sentencia `else` puede seguir un `if` para hacer *algo más* cuando la condición de *if* no es verdadera."
            },
            "pt-BR": {
                "description": "A cláusula `else` (senão) pode acompanhar um `if` para fazer *else* quando  a condição *if* não for verdadeira."
            },
            "el": {
                "description": "Η εντολή `else` μπορεί να ακολουθεί ένα` if`  για να κάνουμε κάτι άλλο η σύνθηκη του `if` δεν είναι αλήθεια."
            },
            "de-DE": {
                "description": "Die Teil-Anweisung `else` kann einem `if` folgen, um etwas *sontiges* zu machen, wenn die *if* Bedingung nicht wahr ist."
            },
            "it": {
                "description": "La condizione `if` (se) può essere seguita da un `else` (altrimenti) per fare qualcosa se la condizione *if* non è vera."
            },
            "fr": {
                "description": "`else` peut se trouver derrière un  `if` pour faire quelque chose d'*autre* quand la condition *si* n'est pas respectée."
            },
            "ru": {
                "description": "оператор `else` может сопровождать `if` чтобы сделать что-то *else* (другое), когда утверждение *if* (если) является ложным."
            },
            "-": {
                "-": "-"
            }
        },
        "snippets": {
            "python": {
                "code": "else:\n    ${1:}",
                "tab": "else"
            },
            "coffeescript": {
                "code": "else\n    ${1:}",
                "tab": "else"
            },
            "lua": {
                "code": "else\n    ${1:}",
                "tab": "else"
            },
            "io": {
                "code": "else(\n    ${1:}\n)",
                "tab": "else"
            },
            "javascript": {
                "tab": "else",
                "code": "else {\n    ${1:}\n}"
            }
        },
        "example": {
            "io": "if(isReady(\"cleave\")) then(\n    cleave(enemy)\n) else(\n    attack(enemy)\n)",
            "clojure": "(if (.isReady this \"cleave\")\n    (.cleave this enemy) ;; if true\n    (.attack this enemy) ;; else\n)",
            "lua": "if self:isReady(\"cleave\") then\n    self:cleave(enemy)\nelse\n    self:attack(enemy)\nend",
            "coffeescript": "if @isReady(\"cleave\")\n    @cleave enemy\nelse\n    @attack enemy",
            "python": "if self.isReady(\"cleave\"):\n    self.cleave(enemy)\nelse:\n    self.attack(enemy)",
            "javascript": "if (this.isReady(\"cleave\")) {\n    this.cleave(enemy);\n}\nelse {\n    this.attack(enemy);\n}"
        },
        "description": "The `else` clause can follow an `if` to do something *else* when the *if* condition is not true.",
        "type": "snippet",
        "name": "else"
    },
    {
        "owner": "snippets",
        "i18n": {
            "zh-HANT": {
                "name": "打斷"
            },
            "da": {
                "description": "`break`-erklæringen afslutter en løkke."
            },
            "pl": {
                "description": "Słowo `break` (złam) przerywa pętlę."
            },
            "nl-NL": {
                "description": "De 'break' statement beïndigd een loop."
            },
            "es-ES": {
                "description": "La instrucción 'break' indica la finalización de un búcle."
            },
            "es-419": {
                "description": "La sentencia `break` termina un bucle."
            },
            "pt-BR": {
                "description": "O comando `break` (parar) termina o loop."
            },
            "el": {
                "description": "Η εντολή `break` τερματίζει ένα επαναληπτικό βρόχο."
            },
            "de-DE": {
                "description": "Die `break` Anweisung beendet eine Schleife."
            },
            "ru": {
                "description": "Ключевое слово `break` прерывает выполнение цикла."
            },
            "lt": {
                "description": "Komanda `break` nutraukia ciklą"
            },
            "it": {
                "description": "L'istruzione `break` termina un ciclo."
            },
            "fr": {
                "description": "La déclaration `break` termine une boucle."
            },
            "-": {
                "-": "-"
            }
        },
        "codeLanguages": [
            "javascript",
            "python",
            "coffeescript",
            "lua",
            "io"
        ],
        "example": {
            "io": "while(true,\n    enemy := findNearest findEnemies\n    if(enemy == nil) then(\n        break\n    )\n    attack(enemy)\n)\nsay(\"／人 ◕ ‿‿ ◕ 人＼\")",
            "lua": "while true do\n    local enemy = self:findNearest(self:findEnemies())\n    if not enemy then\n        break\n    end\n    self:attack(enemy)\nend\nself:say(\"／人 ◕ ‿‿ ◕ 人＼\")",
            "python": "while True:\n    enemy = self.findNearest(self.findEnemies())\n    if not enemy:\n        break\n    self.attack(enemy)\nself.say(\"／人 ◕ ‿‿ ◕ 人＼\")",
            "coffeescript": "while true\n    enemy = @findNearest @findEnemies()\n    break unless enemy\n    @attack enemy\n@say \"／人 ◕ ‿‿ ◕ 人＼\"",
            "javascript": "while (true) {\n    var enemy = this.findNearest(this.findEnemies());\n    if (!enemy) {\n        break;\n    }\n    this.attack(enemy);\n}\nthis.say(\"／人 ◕ ‿‿ ◕ 人＼\");"
        },
        "description": "The `break` statement terminates a loop.",
        "type": "snippet",
        "name": "break"
    },
    {
        "owner": "snippets",
        "i18n": {
            "da": {
                "description": "`continue`-erklæringen springer over resten af igangværende iteration og hopper til den næste."
            },
            "pl": {
                "description": "Słowo `continue` (kontynuuj) pomija tą iterację pętli i idzie do następnej."
            },
            "nl-NL": {
                "description": "De 'continue' statement slaat een herhaling (iteratie) van een loop over, en gaat door naar de volgende herhaling."
            },
            "es-ES": {
                "description": "La insrucción 'continue' finaliza la iteración actual del búcle y pasa a la siguiente."
            },
            "es-419": {
                "description": "La sentencia `continue` omite esta iteración de un bucle y va a la siguiente."
            },
            "pt-BR": {
                "description": "O comando `continue` pula a interação do loop e vai para o próximo."
            },
            "el": {
                "description": "Η εντολή `continue` προσπερνάει τη εκτέλεση της  επανάληψη ενός βρόχου και πηγαίνει στο επόμενο."
            },
            "de-DE": {
                "description": "Die `continue` Anweisung überspringt diese Wiederholung einer Schleife und geht zur Nächsten über."
            },
            "ru": {
                "description": "Ключевое слово `continue` прерывает текущую итерацию и запускает новую с начала цикла."
            },
            "lt": {
                "description": "Komanda `continue` praleidžia likusias cikle komandas ir pradeda sekančią ciklo iteraciją."
            },
            "it": {
                "description": "L'istruzione `continue` permette di saltare un'iterazione del ciclo e passare alla prossima."
            },
            "fr": {
                "description": "La déclaration `continue` saute une répétition d'une boucle et passe à la suivante."
            },
            "-": {
                "-": "-"
            }
        },
        "codeLanguages": [
            "javascript",
            "python",
            "coffeescript",
            "lua",
            "io"
        ],
        "example": {
            "io": "friends := findFriends\nfor(friendIndex, 0, friends size,\n    if(friend type == 'griffin-rider' or friend type == 'paladin') then(\n        continue\n    )\n    command(friend, \"attack\", friend findNearestEnemy)\n)",
            "lua": "friends = self:findFriends()\nfor friendIndex, friend in pairs(friends) do\n    if friend.type == 'griffin-rider' or friend.type == 'paladin' then\n        continue\n    end\n    self:command(friend, \"attack\", friend:findNearestEnemy())\nend",
            "python": "friends = self.findFriends()\nfor friend in friends:\n    if friend.type not in self.commandableTypes:\n        continue\n    self.command(friend, \"attack\", friend.findNearestEnemy())\n",
            "coffeescript": "friends = @findFriends()\nfor friend in friends\n    continue unless friend.type in @commandableTypes\n    @command friend, \"attack\", friend.findNearestEnemy()\n",
            "javascript": "var friends = this.findFriends();\nfor (var friendIndex = 0; friendIndex < friends.length; friendIndex++) {\n    var friend = friends[friendIndex];\n    if (this.commandableTypes.indexOf(friend.type) == -1) {\n        continue;\n    }\n    this.command(friend, \"attack\", friend.findNearestEnemy());\n}"
        },
        "description": "The `continue` statement skips this iteration of a loop and goes to the next one.",
        "type": "snippet",
        "name": "continue"
    },
    {
        "i18n": {
            "-": {
                "-": "-"
            }
        },
        "autoCompletePriority": 3,
        "context": {
            "attacking_over_and_over": "Example: attack an enemy over and over.",
            "looping_through_a_maze": "Example: looping through a maze."
        },
        "owner": "snippets",
        "snippets": {
            "lua": {
                "tab": "while true do",
                "code": "while true do\n    ${1:}\nend"
            },
            "coffeescript": {
                "tab": "while true",
                "code": "while true\n    ${1:}"
            },
            "python": {
                "tab": "while True:",
                "code": "while True:\n    ${1:}"
            },
            "javascript": {
                "code": "while(true) {\n    ${1:}\n}",
                "tab": "while(true) {"
            }
        },
        "example": {
            "lua": "-- <%= looping_through_a_maze %>\nwhile true do\n    hero:moveRight()\n    hero:moveDown()\n    hero:moveRight()\n    hero:moveUp()\nend\n\n-- <%= attacking_over_and_over %>\nwhile true do\n    local enemy = hero:findNearestEnemy()\n    if enemy then\n        hero:attack(enemy)\n    end\nend",
            "coffeescript": "# <%= looping_through_a_maze %>\nwhile true\n    @moveRight()\n    @moveDown()\n    @moveUp()\n    @moveRight()\n\n# <%= attacking_over_and_over %>\nwhile true\n    enemy = @findNearestEnemy()\n    if enemy\n        @attack enemy",
            "python": "# <%= looping_through_a_maze %>\nwhile True:\n    hero.moveRight()\n    hero.moveDown()\n    hero.moveRight()\n    hero.moveUp()\n\n# <%= attacking_over_and_over %>\nwhile True:\n    enemy = hero.findNearestEnemy()\n    if enemy:\n        hero.attack(enemy)",
            "javascript": "// <%= looping_through_a_maze %>\nwhile(true) {\n    hero.moveRight();\n    hero.moveDown();\n    hero.moveRight();\n    hero.moveUp();\n}\n\n// <%= attacking_over_and_over %>\nwhile(true) {\n    var enemy = hero.findNearestEnemy();\n    if (enemy) {\n        hero.attack(enemy);\n    }\n}"
        },
        "description": {
            "lua": "Using a `while-true loop` lets you run code over and over again. Put the code to repeat inside the `while true do` and `end` keywords, with four spaces before each line.",
            "coffeescript": "Using a `while-true loop` lets you run code over and over again. Put **four spaces** before each line to repeat or it won't work!",
            "python": "Using a `while-true loop` lets you run code over and over again. Put **four spaces** before each line to repeat or it won't work!",
            "javascript": "Using a `while-true loop` lets you run code over and over again. Put the code to repeat inside the `{` and `}` curly braces with four spaces before each line."
        },
        "type": "snippet",
        "name": "while-true loop"
    }
]