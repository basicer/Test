{
	"_id": "54da61ea04a0744a08c06d10",
	"slug": "sacredstatuereferee",
	"searchStrings": "sacred statue referee s sa sac sacr sacre sacred sacreds sacredst sacredsta sacredstat sacredstatu sacredstatue sacredstatuer sacredstatuere sacredstatueref sacredstatuerefe sacredstatuerefer",
	"name": "SacredStatueReferee",
	"js": "var SacredStatueReferee, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nSacredStatueReferee = (function(_super) {\n  __extends(SacredStatueReferee, _super);\n\n  function SacredStatueReferee() {\n    _ref = SacredStatueReferee.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  SacredStatueReferee.className = 'SacredStatueReferee';\n\n  SacredStatueReferee.prototype.chooseAction = function() {\n    var _base, _base1, _base2, _base3, _base4;\n    this.checkVictory();\n    this.configure();\n    this.decrementTimers();\n    this.companionRoutine();\n    this.statueRadiance();\n    if (this.ellipses['statue-radius'].containsPoint(this.hero.pos) && !this.enemiesCleared() && !this.events.statueTriggered) {\n      return typeof (_base = this.statue).say === \"function\" ? _base.say(\"There is a foul presence nearby, please eliminate the threat\") : void 0;\n    } else if (!this.ellipses['statue-radius'].containsPoint(this.hero.pos) && this.enemiesCleared() && !this.events.dialog1) {\n      return typeof (_base1 = this.statue).say === \"function\" ? _base1.say(\"Come closer, hero!\") : void 0;\n    } else if (this.ellipses['statue-radius'].containsPoint(this.hero.pos) && !this.events.dialog1) {\n      if (typeof (_base2 = this.statue).say === \"function\") {\n        _base2.say(\"You are just in time great champion, the ogres are preparing an attack!\");\n      }\n      this.events.dialog1 = this.world.age;\n      return this.events.statueTriggered = true;\n    } else if (this.events.dialog1 && (this.world.age - this.events.dialog1) >= 4 && !this.events.dialog2) {\n      if (typeof (_base3 = this.statue).say === \"function\") {\n        _base3.say(\"You cannot not let them desecrate this holy ground.\");\n      }\n      return this.events.dialog2 = this.world.age;\n    } else if (this.events.dialog2 && (this.world.age - this.events.dialog2) >= 4 && !this.events.dialog3) {\n      if (typeof (_base4 = this.statue).say === \"function\") {\n        _base4.say(\"Stay close to me during the battle so I can assist you!\");\n      }\n      this.events.dialog3 = this.world.age;\n      return this.statueActive = true;\n    } else if (this.events.dialog3 && (this.world.age - this.events.dialog3) >= 4 && !this.events.spawnsBegin) {\n      this.events.spawnsBegin = true;\n      return this.currentWave = 1;\n    } else if (this.currentWave > this.numberOfWaves && this.timers.waveTimer <= 0 && this.enemiesCleared() && !this.events.bossSpawn) {\n      this.spawnBoss();\n      return this.events.bossSpawn = true;\n    } else if (this.events.spawnsBegin && !this.events.bossSpawn) {\n      return this.generateWaves();\n    }\n  };\n\n  SacredStatueReferee.prototype.setUpLevel = function() {\n    this.hero = this.world.getThangByID('Hero Placeholder');\n    this.statue = this.world.getThangByID('Sacred Statue');\n    this.cyclops = this.world.getThangByID('Ancient Cyclops');\n    this.events = {\n      'statueTriggered': false,\n      'dialog1': false,\n      'dialog2': false,\n      'dialog3': false,\n      'spawnsBegin': false,\n      'bossSpawn': false\n    };\n    this.spawnLocations = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\n    this.aura = {\n      \"currentColor\": false,\n      \"normalColor\": 'rgba(255, 255, 128, 0.24)',\n      \"blastColor\": 'rgba(255, 0, 0, 0.18)'\n    };\n    this.timers = {\n      \"statueTimer\": 0,\n      \"waveTimer\": 0,\n      \"waveCooldown\": 0,\n      \"buildUpTimer\": 0\n    };\n    this.statueActive = false;\n    this.numberOfWaves = 3;\n    this.waveDuration = 10;\n    this.waveTimeout = 0;\n    this.nextWaveQueued = false;\n    return this.removeStaticUnits = {\n      \"shaman\": false,\n      \"throwers\": false,\n      \"scouts\": false\n    };\n  };\n\n  SacredStatueReferee.prototype.configure = function() {\n    var _ref1;\n    if (!!this.configured) {\n      return;\n    }\n    if ((_ref1 = this.hero.type) === 'captain' || _ref1 === 'knight' || _ref1 === 'samurai' || _ref1 === 'ninja' || _ref1 === 'trapper') {\n      this.companion = this.instabuild(\"healer-hero\", -2, 14);\n    } else {\n      this.companion = this.instabuild(\"melee-hero\", -2, 14);\n    }\n    this.aura.currentColor = this.aura.normalColor;\n    this.healRate = (2.4 / 100) * this.hero.maxHealth;\n    this.healRate = this.healRate > 40 ? 40 : this.healRate;\n    return this.configured = true;\n  };\n\n  SacredStatueReferee.prototype.configureCyclops = function() {\n    this.cyclops.maxHealth = (this.hero.maxHealth / 5) * 4;\n    this.cyclops.health = this.cyclops.maxHealth;\n    this.cyclops.addTrackedProperties(['health', 'number']);\n    this.cyclops.keepTrackedProperty('health');\n    this.cyclops.attackDamage = this.hero.maxHealth / ((9 / 100) * this.hero.maxHealth) + ((3.5 / 100) * this.hero.maxHealth);\n    this.cyclops.attackDamage = this.cyclops.attackDamage > 70 ? 70 : this.cyclops.attackDamage;\n    this.cyclops.attackDamage += this.world.difficulty * 6;\n    this.cyclops.addTrackedProperties(['attackDamage', 'number']);\n    return this.cyclops.keepTrackedProperty('attackDamage');\n  };\n\n  SacredStatueReferee.prototype.decrementTimers = function() {\n    var name, timer, _ref1, _results;\n    _ref1 = this.timers;\n    _results = [];\n    for (name in _ref1) {\n      timer = _ref1[name];\n      _results.push(this.timers[name] -= this.world.dt);\n    }\n    return _results;\n  };\n\n  SacredStatueReferee.prototype.createRectangle = function(name, rect) {\n    return this.rectangles[name] = rect;\n  };\n\n  SacredStatueReferee.prototype.assignWaveRegion = function(wave, region, rect) {\n    this.createRectangle(region, rect);\n    return _.find(this.waves, {\n      name: wave\n    }).regions = [region];\n  };\n\n  SacredStatueReferee.prototype.companionRoutine = function() {\n    var distance, enemy;\n    this.companionMovement();\n    enemy = this.companion.findNearestEnemy();\n    if (enemy) {\n      distance = this.companion.distanceTo(enemy);\n    }\n    if (this.companion.type === \"healer\") {\n      if (this.hero.health < this.hero.maxHealth && this.companion.canCast(\"regen\", this.hero)) {\n        this.companion.cast(\"regen\", this.hero);\n      } else if (this.companion.health < this.companion.maxHealth && this.companion.canCast(\"regen\", this.companion)) {\n        this.companion.cast(\"regen\", this.companion);\n      }\n      if (enemy && distance) {\n        if (distance <= 35) {\n          return this.companion.attack(enemy);\n        }\n      }\n    } else {\n      if (enemy && distance) {\n        if (distance <= 5) {\n          if (this.companion.isReady(\"bash\")) {\n            this.companion.bash(enemy);\n          }\n          if (this.companion.isReady(\"cleave\")) {\n            this.companion.cleave(enemy);\n          }\n          return this.companion.attack(enemy);\n        }\n      }\n    }\n  };\n\n  SacredStatueReferee.prototype.companionMovement = function() {\n    if (!this.companion.dead && !this.hero.dead) {\n      return this.companion.move(Vector.subtract(this.companion.pos, this.hero.pos).normalize().multiply(3).add(this.hero.pos));\n    }\n  };\n\n  SacredStatueReferee.prototype.nerfStatics = function() {\n    var count, scout, scouts, shaman, shamans, t, thrower, throwers, _i, _j, _k, _len, _len1, _len2, _results;\n    this.removeStaticUnits.shaman = true;\n    this.removeStaticUnits.throwers = true;\n    this.removeStaticUnits.scouts = 1;\n    if (this.removeStaticUnits.shaman) {\n      shamans = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.world.getSystem(\"Combat\").attackables;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          t = _ref1[_i];\n          if (t.isAttackable && t.type === \"shaman\" && t !== this.hero) {\n            _results.push(t);\n          }\n        }\n        return _results;\n      }).call(this);\n      for (_i = 0, _len = shamans.length; _i < _len; _i++) {\n        shaman = shamans[_i];\n        shaman.isAttackable = false;\n        shaman.setExists(false);\n      }\n    }\n    if (this.removeStaticUnits.throwers) {\n      throwers = (function() {\n        var _j, _len1, _ref1, _results;\n        _ref1 = this.world.getSystem(\"Combat\").attackables;\n        _results = [];\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          t = _ref1[_j];\n          if (t.isAttackable && t.type === \"thrower\" && t !== this.hero) {\n            _results.push(t);\n          }\n        }\n        return _results;\n      }).call(this);\n      for (_j = 0, _len1 = throwers.length; _j < _len1; _j++) {\n        thrower = throwers[_j];\n        thrower.isAttackable = false;\n        thrower.setExists(false);\n      }\n    }\n    if (this.removeStaticUnits.scouts) {\n      count = 0;\n      scouts = (function() {\n        var _k, _len2, _ref1, _results;\n        _ref1 = this.world.getSystem(\"Combat\").attackables;\n        _results = [];\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          t = _ref1[_k];\n          if (t.isAttackable && t.type === \"scout\" && t !== this.hero) {\n            _results.push(t);\n          }\n        }\n        return _results;\n      }).call(this);\n      _results = [];\n      for (_k = 0, _len2 = scouts.length; _k < _len2; _k++) {\n        scout = scouts[_k];\n        if (this.removeStaticUnits.scouts && count < this.removeStaticUnits.scouts) {\n          scout.isAttackable = false;\n          scout.setExists(false);\n          _results.push(count++);\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    }\n  };\n\n  SacredStatueReferee.prototype.spawnBoss = function() {\n    var r, spawnPoint, _base;\n    this.cyclops.appearanceDelay = 0;\n    r = Math.round(this.world.rand.randf2(0, 3));\n    spawnPoint = this.pickPointFromRegions([this.ellipses[this.spawnLocations[r]]]);\n    this.configureCyclops();\n    if (typeof (_base = this.cyclops).say === \"function\") {\n      _base.say(\"GRRRAAWWR!\");\n    }\n    return this.cyclops.attack(this.hero);\n  };\n\n  SacredStatueReferee.prototype.generateWaves = function() {\n    var r, r2;\n    if (!this.nextWaveQueued) {\n      if (this.timers.waveTimer <= 0 && this.timers.waveCooldown <= 0 && this.enemiesCleared()) {\n        this.nextWaveQueued = true;\n        this.timers.waveCooldown = 5;\n      } else {\n        this.timers.waveTimer = 1;\n      }\n    }\n    if (!(((this.timers.waveTimer <= 0 && this.timers.waveCooldown <= 0) || this.world.age - this.waveTimeout >= 20) && this.currentWave <= this.numberOfWaves)) {\n      return;\n    }\n    r = Math.round(this.world.rand.randf2(0, 3));\n    r2 = Math.round(this.world.rand.randf2(0, 3));\n    while (r2 === r) {\n      r2 = Math.round(this.world.rand.randf2(0, 3));\n    }\n    this.spawnWaveNamed(this.spawnLocations[r] + \"-initial\");\n    this.spawnWaveNamed(this.spawnLocations[r2] + \"-initial\");\n    this.spawnWaveNamed(this.spawnLocations[r] + \"-duration\");\n    this.spawnWaveNamed(this.spawnLocations[r2] + \"-duration\");\n    this.sendEnemies();\n    this.waveTimeout = this.world.age;\n    this.timers.waveTimer = this.waveDuration;\n    return this.currentWave++;\n  };\n\n  SacredStatueReferee.prototype.emitAura = function() {\n    var args;\n    if (this.statueActive && this.world.frames.length % 4 === 0 && this.world.rand.randf() < 0.75) {\n      args = [61.5, 71, 17, this.aura.currentColor, 0, 0, \"floating\"];\n      return typeof this.addCurrentEvent === \"function\" ? this.addCurrentEvent(\"aoe-\" + (JSON.stringify(args))) : void 0;\n    }\n  };\n\n  SacredStatueReferee.prototype.thangAura = function(thangs, color) {\n    var args, thang, _i, _len, _results;\n    if (this.statueActive && this.world.frames.length % 2 === 0 && this.world.rand.randf() < 0.75) {\n      _results = [];\n      for (_i = 0, _len = thangs.length; _i < _len; _i++) {\n        thang = thangs[_i];\n        args = [thang.pos.x.toFixed(2), thang.pos.y.toFixed(2), 4 * thang.scaleFactor, color, 0, 0, \"floating\"];\n        _results.push(typeof thang.addCurrentEvent === \"function\" ? thang.addCurrentEvent(\"aoe-\" + (JSON.stringify(args))) : void 0);\n      }\n      return _results;\n    }\n  };\n\n  SacredStatueReferee.prototype.statueRadiance = function() {\n    var enemies, enemy, friend, friends, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;\n    this.emitAura();\n    enemies = (function() {\n      var _i, _len, _ref1, _results;\n      _ref1 = this.world.getSystem(\"Combat\").attackables;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        t = _ref1[_i];\n        if (t.isAttackable && t.team === \"ogres\" && t !== this.hero && this.ellipses['statue-radius'].containsPoint(t.pos)) {\n          _results.push(t);\n        }\n      }\n      return _results;\n    }).call(this);\n    friends = (function() {\n      var _i, _len, _ref1, _results;\n      _ref1 = this.world.thangs;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        t = _ref1[_i];\n        if (t.team === 'humans' && t.exists && t.health >= 0 && this.ellipses['statue-radius'].containsPoint(t.pos)) {\n          _results.push(t);\n        }\n      }\n      return _results;\n    }).call(this);\n    this.thangAura(enemies, this.aura.blastColor);\n    this.thangAura(friends, this.aura.normalColor);\n    if (!(this.statueActive && this.timers.statueTimer <= 0)) {\n      return;\n    }\n    this.aura.currentColor = this.aura.normalColor;\n    if (enemies.length > 3 && this.timers.buildUpTimer <= 0) {\n      if (typeof this.say === \"function\") {\n        this.say(\"** Energy blast released! **\");\n      }\n      this.aura.currentColor = this.aura.blastColor;\n      for (_i = 0, _len = friends.length; _i < _len; _i++) {\n        friend = friends[_i];\n        if (friend.health < friend.maxHealth) {\n          friend.health += this.healRate * 25;\n        }\n      }\n      for (_j = 0, _len1 = enemies.length; _j < _len1; _j++) {\n        enemy = enemies[_j];\n        enemy.health -= this.healRate * 5;\n        enemy.addTrackedProperties(['health', 'number']);\n        enemy.keepTrackedProperty('health');\n      }\n      this.timers.buildUpTimer = 12;\n    }\n    for (_k = 0, _len2 = friends.length; _k < _len2; _k++) {\n      friend = friends[_k];\n      if (friend.health < friend.maxHealth) {\n        if (this.enemiesCleared()) {\n          friend.health += this.healRate * 2;\n        } else {\n          friend.health += this.healRate;\n        }\n      }\n    }\n    for (_l = 0, _len3 = enemies.length; _l < _len3; _l++) {\n      enemy = enemies[_l];\n      enemy.health -= this.healRate / 16;\n      enemy.addTrackedProperties(['health', 'number']);\n      enemy.keepTrackedProperty('health');\n    }\n    enemies = (function() {\n      var _len4, _m, _ref1, _results;\n      _ref1 = this.world.getSystem(\"Combat\").attackables;\n      _results = [];\n      for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {\n        t = _ref1[_m];\n        if (t.isAttackable && t.team === \"ogres\" && t !== this.hero) {\n          _results.push(t);\n        }\n      }\n      return _results;\n    }).call(this);\n    for (_m = 0, _len4 = enemies.length; _m < _len4; _m++) {\n      enemy = enemies[_m];\n      if (this.statue.distanceTo(enemy) > 10) {\n        this.vortex(enemy);\n      }\n    }\n    return this.timers.statueTimer = 0.35;\n  };\n\n  SacredStatueReferee.prototype.vortex = function(enemy) {\n    var momentum, ratio;\n    ratio = 1 - this.statue.pos.distance(enemy.pos) / 35;\n    momentum = this.statue.pos.copy().subtract(enemy.pos, true).multiply(ratio * (75 - (this.statue.distanceTo(enemy) * 1.2)), true);\n    enemy.velocity.add(momentum.divide(enemy.mass, true), true);\n    return enemy.rotation = (enemy.velocity.heading() + Math.PI) % (2 * Math.PI);\n  };\n\n  SacredStatueReferee.prototype.sendEnemies = function() {\n    var enemies, enemy, t, _i, _len, _results;\n    enemies = (function() {\n      var _i, _len, _ref1, _results;\n      _ref1 = this.world.getSystem(\"Combat\").attackables;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        t = _ref1[_i];\n        if (t.isAttackable && t.team === \"ogres\" && !t.dead && t !== this.hero) {\n          _results.push(t);\n        }\n      }\n      return _results;\n    }).call(this);\n    _results = [];\n    for (_i = 0, _len = enemies.length; _i < _len; _i++) {\n      enemy = enemies[_i];\n      _results.push(enemy.attack(this.hero));\n    }\n    return _results;\n  };\n\n  SacredStatueReferee.prototype.enemiesCleared = function() {\n    var enemies, t;\n    enemies = (function() {\n      var _i, _len, _ref1, _results;\n      _ref1 = this.world.getSystem(\"Combat\").attackables;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        t = _ref1[_i];\n        if (t.isAttackable && t.team === \"ogres\" && !t.dead && t !== this.hero) {\n          _results.push(t);\n        }\n      }\n      return _results;\n    }).call(this);\n    return enemies.length < 1;\n  };\n\n  SacredStatueReferee.prototype.checkVictory = function() {\n    if (this.hero.health <= 0) {\n      this.setGoalState('protect', 'failure');\n      this.setGoalState('survive', 'failure');\n      return this.setGoalState('cyclops', 'failure');\n    } else if (this.events.bossSpawn && this.cyclops.health <= 0 && this.enemiesCleared() && this.hero.health > 0) {\n      this.setGoalState('protect', 'success');\n      this.setGoalState('survive', 'success');\n      return this.setGoalState('cyclops', 'success');\n    }\n  };\n\n  return SacredStatueReferee;\n\n})(Component);\n",
	"system": "misc",
	"creator": "546d4b4fa06acfd60c5ea198",
	"original": "54c31757cb986e5505c0013c",
	"watchers": [
		"546d4b4fa06acfd60c5ea198",
		"512ef4805a67a8c507000001",
		"5162fab9c92b4c751e000274"
	],
	"__v": 0,
	"commitMessage": "added dead check to enemiesCleared",
	"index": true,
	"parent": "54da5fb5424cd13b080c5bd5",
	"created": "2015-02-10T19:54:18.672Z",
	"version": {
		"isLatestMinor": true,
		"isLatestMajor": true,
		"minor": 56,
		"major": 0
	},
	"permissions": [
		{
			"access": "owner",
			"target": "546d4b4fa06acfd60c5ea198"
		},
		{
			"access": "read",
			"target": "public"
		}
	]
}