{
	"_id": "5795a80ce0ab2d26009f6a9b",
	"searchStrings": "plan referee p pl pla plan planr planre planref planrefe planrefer",
	"index": true,
	"slug": "planreferee",
	"name": "PlanReferee",
	"js": "var PlanReferee, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nPlanReferee = (function(_super) {\n  __extends(PlanReferee, _super);\n\n  function PlanReferee() {\n    _ref = PlanReferee.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  PlanReferee.className = 'PlanReferee';\n\n  PlanReferee.prototype.attach = function(thang) {\n    return PlanReferee.__super__.attach.call(this, thang);\n  };\n\n  PlanReferee.prototype.planLinesContainingString = function(query) {\n    var f, rv,\n      _this = this;\n    rv = [];\n    f = function(expr, type, depth) {\n      if (expr.search(query) !== -1) {\n        return rv.push(expr);\n      }\n    };\n    this.planWalkLogicalLines(f);\n    return rv;\n  };\n\n  PlanReferee.prototype.planNodesByType = function(xtype) {\n    return [];\n  };\n\n  PlanReferee.prototype.planWalkLogicalLines = function(callback) {\n    var body, expr, _i, _len, _results;\n    body = this.planFindBody();\n    if (!body) {\n      return;\n    }\n    _results = [];\n    for (_i = 0, _len = body.length; _i < _len; _i++) {\n      expr = body[_i];\n      _results.push(this._planWalkLogicalLines(expr, callback, 0));\n    }\n    return _results;\n  };\n\n  PlanReferee.prototype._planWalkLogicalLines = function(o, callback, depth) {\n    var expr, _i, _len, _ref1, _results;\n    if (!o) {\n      return;\n    }\n    if (!o.type) {\n      return;\n    }\n    switch (o.type) {\n      case 'BlockStatement':\n        _ref1 = o.body;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          expr = _ref1[_i];\n          _results.push(this._planWalkLogicalLines(expr, callback, depth));\n        }\n        return _results;\n        break;\n      case 'IfStatement':\n      case 'ConditionalExpression':\n        callback(this.planFormatExpression(o), o.type, depth);\n        this._planWalkLogicalLines(o.consequent, callback, depth + 1);\n        if (o.alternate) {\n          callback(this.planFormatExpression({\n            'type': 'ElseStatement'\n          }), 'ElseStatement', depth);\n          return this._planWalkLogicalLines(o.alternate, callback, depth + 1);\n        }\n        break;\n      case 'WhileStatement':\n      case 'FunctionExpression':\n      case 'FunctionDeclaration':\n      case 'ForStatement':\n      case 'ForInStatement':\n        callback(this.planFormatExpression(o), o.type, depth);\n        return this._planWalkLogicalLines(o.body, callback, depth + 1);\n      default:\n        return callback(this.planFormatExpression(o), o.type, depth);\n    }\n  };\n\n  PlanReferee.prototype.planFormatExpression = function(o) {\n    var aa, ba, buf, ca, cc, decl, fa, fi, i, ia, ka, la, lhs, mo, mp, na, nc, oa, pa, ra, rhs, ta, ua, va, vn, vv, _i, _len, _ref1;\n    if (!o) {\n      return ' ';\n    }\n    if (!o.type) {\n      return '' + o;\n    }\n    switch (o.type) {\n      case 'EmptyStatement':\n        return '';\n      case 'ThisExpression':\n        return 'this';\n      case 'Literal':\n        return '\"' + o.value + '\"';\n      case 'Identifier':\n        return o.name;\n      case 'ExpressionStatement':\n        return 'expr(' + this.planFormatExpression(o.expression) + ')';\n      case 'MemberExpression':\n        mo = this.planFormatExpression(o.object);\n        mp = this.planFormatExpression(o.property);\n        return mo + '.' + mp;\n      case 'Property':\n        ka = this.planFormatExpression(o.key);\n        va = this.planFormatExpression(o.value);\n        return ka + ':' + va;\n      case 'AssignmentExpression':\n        lhs = this.planFormatExpression(o.left);\n        rhs = this.planFormatExpression(o.right);\n        return lhs + '=' + rhs;\n      case 'VariableDeclaration':\n        buf = [];\n        _ref1 = o.declarations;\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          decl = _ref1[_i];\n          vn = decl.id.name;\n          vv = this.planFormatExpression(decl.init, vn);\n          buf.push(vn + '=' + vv);\n        }\n        return buf.join(',');\n      case 'CallExpression':\n        cc = this.planFormatExpression(o.callee);\n        ca = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o[\"arguments\"];\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join(',');\n        return cc + '(' + ca + ')';\n      case 'NewExpression':\n        nc = this.planFormatExpression(o.callee);\n        na = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o[\"arguments\"];\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join(',');\n        return 'new ' + nc + '(' + na + ')';\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        lhs = this.planFormatExpression(o.left);\n        rhs = this.planFormatExpression(o.right);\n        return '(' + lhs + ')' + o.operator + '(' + rhs + ')';\n      case 'UnaryExpression':\n      case 'UpdateExpression':\n        oa = this.planFormatExpression(o.operator);\n        aa = this.planFormatExpression(o.argument);\n        if (o.prefix) {\n          return oa + '(' + aa + ')';\n        } else {\n          return '(' + aa + ')' + oa;\n        }\n        break;\n      case 'FunctionExpression':\n      case 'FunctionDeclaration':\n        fi = this.planFormatExpression(o.id);\n        fa = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o.params;\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join(',');\n        return 'function ' + fi + '(' + fa + '):';\n      case 'ArrayExpression':\n        aa = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o.elements;\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join(',');\n        return '[' + aa + ']';\n      case 'ObjectExpression':\n        pa = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o.properties;\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join(',');\n        return '{' + pa + '}';\n      case 'IfStatement':\n      case 'ConditionalExpression':\n        ta = this.planFormatExpression(o.test);\n        return 'if(' + ta + '):';\n      case 'ElseStatement':\n        return 'else:';\n      case 'ForStatement':\n        ia = this.planFormatExpression(o.init);\n        ta = this.planFormatExpression(o.test);\n        ua = this.planFormatExpression(o.update);\n        return 'for (' + ia + ';' + ta + ';' + ua + '):';\n      case 'ForInStatement':\n        la = this.planFormatExpression(o.left);\n        ra = this.planFormatExpression(o.right);\n        return 'for (' + la + ') in (' + ra + '):';\n      case 'WhileStatement':\n        ta = this.planFormatExpression(o.test);\n        return 'while ' + ta + ':';\n      case 'ContinueStatement':\n        return 'continue';\n      case 'BreakStatement':\n        return 'break';\n      case 'ReturnStatement':\n        if (o.argument) {\n          return 'return ' + this.planFormatExpression(o.argument);\n        } else {\n          return 'return';\n        }\n        break;\n      case 'BlockStatement':\n        ba = ((function() {\n          var _j, _len1, _ref2, _results;\n          _ref2 = o.body;\n          _results = [];\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            i = _ref2[_j];\n            _results.push(this.planFormatExpression(i));\n          }\n          return _results;\n        }).call(this)).join('; ');\n        return '{' + ba + '}';\n      default:\n        this.planDumpKeys(o);\n        return o.type;\n    }\n    return '' + o;\n  };\n\n  PlanReferee.prototype.planDumpKeys = function(o) {\n    var i, _i, _len, _ref1, _results;\n    if (!o) {\n      console.log('nothing', o);\n    }\n    _ref1 = Object.keys(o);\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(console.log(i, o[i]));\n    }\n    return _results;\n  };\n\n  PlanReferee.prototype.planIndent = function(s, depth, tabwidth) {\n    var i, j, rv, _i, _j;\n    if (tabwidth == null) {\n      tabwidth = 4;\n    }\n    rv = '' + s;\n    for (i = _i = 0; 0 <= depth ? _i < depth : _i > depth; i = 0 <= depth ? ++_i : --_i) {\n      for (j = _j = 0; 0 <= tabwidth ? _j < tabwidth : _j > tabwidth; j = 0 <= tabwidth ? ++_j : --_j) {\n        rv = ' ' + rv;\n      }\n    }\n    return rv;\n  };\n\n  PlanReferee.prototype.planFindBody = function() {\n    var abody, b, c, lang, plan, rv, _i, _len, _ref1, _ref2, _ref3, _ref4, _ref5;\n    plan = this.world.userCodeMap['Hero Placeholder'].plan;\n    lang = plan.language.id;\n    abody = (_ref1 = plan.ast) != null ? _ref1.body : void 0;\n    if (!abody) {\n      console.log('No body! Maybe had problems parsing?');\n      return null;\n    }\n    if (lang !== 'coffeescript') {\n      return abody;\n    }\n    rv = null;\n    for (_i = 0, _len = abody.length; _i < _len; _i++) {\n      b = abody[_i];\n      c = b != null ? (_ref2 = b.body) != null ? _ref2.body : void 0 : void 0;\n      if (!c) {\n        c = b != null ? (_ref3 = b.expression) != null ? (_ref4 = _ref3.right) != null ? (_ref5 = _ref4.body) != null ? _ref5.body : void 0 : void 0 : void 0 : void 0;\n      }\n      if (c) {\n        rv = c;\n        break;\n      }\n    }\n    return rv;\n  };\n\n  return PlanReferee;\n\n})(Component);\n",
	"system": "misc",
	"creator": "5446cac8a887c47508b6f945",
	"original": "5785675d0d397a2e0025331c",
	"watchers": [
		"5446cac8a887c47508b6f945"
	],
	"__v": 0,
	"commitMessage": "rough pass at formatting an AST and searching for strings",
	"parent": "578d1f1abb085e1f00d4f445",
	"created": "2016-07-25T05:47:56.592Z",
	"version": {
		"isLatestMinor": true,
		"isLatestMajor": true,
		"minor": 2,
		"major": 0
	},
	"permissions": [
		{
			"access": "owner",
			"target": "5446cac8a887c47508b6f945"
		},
		{
			"access": "read",
			"target": "public"
		}
	]
}